[
   {
      "q": "Operating system routines that directly support application programs as they run are generally:",
      "c": [
         "resident",
         "transient",
         "resilient",
         "dynamic"
      ],
      "a": [
         "resident"
      ]
   },
   {
      "q": "Each physical device attached to an MS-DOS system is described in a special file called a(n):",
      "c": [
         "interrupt vector",
         "FAT",
         "block routine",
         "device driver"
      ],
      "a": [
         "device driver"
      ]
   },
   {
      "q": "To access the services of operating system, the interface is provided by the:",
      "c": [
         "System calls",
         "API",
         "Library",
         "Assembly instructions"
      ],
      "a": [
         "System calls"
      ]
   },
   {
      "q": "Which one of the following is not true?",
      "c": [
         "kernel is the program that constitutes the central core of the operating system",
         "kernel is the first part of operating system to load into memory during booting",
         "kernel is made of various modules which can not be loaded in running operating system",
         "kernel remains in the memory during the entire computer session"
      ],
      "a": [
         "kernel is made of various modules which can not be loaded in running operating system"
      ]
   },
   {
      "q": "Which one of the following error will be handle by the operating system?",
      "c": [
         "power failure",
         "lack of paper in printer",
         "connection failure in the network",
         "all of the mentioned"
      ],
      "a": [
         "all of the mentioned"
      ]
   },
   {
      "q": "By operating system, the resource management can be done via:",
      "c": [
         "time division multiplexing",
         "space division multiplexing",
         "both time and space division multiplexing",
         "none of the mentioned"
      ],
      "a": [
         "both time and space division multiplexing"
      ]
   },
   {
      "q": "If a process fails, most operating system write the error information to a:",
      "c": [
         "log file",
         "another running process",
         "new file",
         "none of the mentioned"
      ],
      "a": [
         "log file"
      ]
   },
   {
      "q": "In operating system, each process has its own:",
      "c": [
         "address space and global variables",
         "open files",
         "pending alarms, signals and signal handlers",
         "all of the mentioned"
      ],
      "a": [
         "all of the mentioned"
      ]
   },
   {
      "q": "In Unix, Which system call creates the new process?",
      "c": [
         "fork",
         "create",
         "new",
         "none of the mentioned"
      ],
      "a": [
         "fork"
      ]
   },
   {
      "q": "A process can be terminated due to:",
      "c": [
         "normal exit",
         "fatal error",
         "killed by another process",
         "all of the mentioned"
      ],
      "a": [
         "all of the mentioned"
      ]
   },
   {
      "q": "What is the ready state of a process?",
      "c": [
         "when process is scheduled to run after some execution",
         "when process is unable to run until some task has been completed",
         "when process is using the CPU",
         "none of the mentioned"
      ],
      "a": [
         "when process is scheduled to run after some execution"
      ]
   },
   {
      "q": "What is interprocess communication?",
      "c": [
         "communication within the process",
         "communication between two process",
         "communication between two threads of same process",
         "none of the mentioned"
      ],
      "a": [
         "communication between two process"
      ]
   },
   {
      "q": "A set of processes is deadlock if:",
      "c": [
         "each process is blocked and will remain so forever",
         "each process is terminated",
         "all processes are trying to kill each other",
         "none of the mentioned"
      ],
      "a": [
         "each process is blocked and will remain so forever"
      ]
   },
   {
      "q": "A process stack does not contain:",
      "c": [
         "Function parameters",
         "Local variables",
         "Return addresses",
         "PID of child process"
      ],
      "a": [
         "PID of child process"
      ]
   },
   {
      "q": "Which system call returns the process identifier of a terminated child?",
      "c": [
         "wait",
         "exit",
         "fork",
         "get"
      ],
      "a": [
         "wait"
      ]
   },
   {
      "q": "The address of the next instruction to be executed by the current process is provided by the:",
      "c": [
         "CPU registers",
         "Program counter",
         "Process stack",
         "Pipe"
      ],
      "a": [
         "Program counter"
      ]
   },
   {
      "q": "A Process Control Block(PCB) does not contain which of the following:",
      "c": [
         "Code",
         "Stack",
         "Bootstrap program",
         "Data"
      ],
      "a": [
         "Bootstrap program"
      ]
   },
   {
      "q": "The number of processes completed per unit time is known as:",
      "c": [
         "Output",
         "Throughput",
         "Efficiency",
         "Capacity"
      ],
      "a": [
         "Throughput"
      ]
   },
   {
      "q": "The state of a process is defined by:",
      "c": [
         "the final activity of the process",
         "the activity just executed by the process",
         "the activity to next be executed by the process",
         "the current activity of the process"
      ],
      "a": [
         "the current activity of the process"
      ]
   },
   {
      "q": "Which of the following is not the state of a process?",
      "c": [
         "New",
         "Old",
         "Waiting",
         "Running"
      ],
      "a": [
         "Old"
      ]
   },
   {
      "q": "The Process Control Block is:",
      "c": [
         "Process type variable",
         "Data Structure",
         "A secondary storage section",
         "A Block in memory"
      ],
      "a": [
         "Data Structure"
      ]
   },
   {
      "q": "The entry of all the PCBs of the current processes is in:",
      "c": [
         "Process Register",
         "Program Counter",
         "Process Table",
         "Process Unit"
      ],
      "a": [
         "Process Table"
      ]
   },
   {
      "q": "The degree of multiprogramming is:",
      "c": [
         "the number of processes executed per unit time",
         "the number of processes in the ready queue",
         "the number of processes in the I/O queue",
         "the number of processes in memory"
      ],
      "a": [
         "the number of processes in memory"
      ]
   },
   {
      "q": "A single thread of control allows the process to perform:",
      "c": [
         "only one task at a time",
         "multiple tasks at a time",
         "only two tasks at a time",
         "all of the mentioned"
      ],
      "a": [
         "only one task at a time"
      ]
   },
   {
      "q": "The objective of multiprogramming is to:",
      "c": [
         "Have some process running at all times",
         "Have multiple programs waiting in a queue ready to run",
         "To minimize CPU utilization",
         "None of the mentioned"
      ],
      "a": [
         "Have some process running at all times"
      ]
   },
   {
      "q": "Which of the following do not belong to queues for processes?",
      "c": [
         "Job Queue",
         "PCB queue",
         "Device Queue",
         "Ready Queue"
      ],
      "a": [
         "PCB queue"
      ]
   },
   {
      "q": "When the process issues an I/O request:",
      "c": [
         "It is placed in an I/O queue",
         "It is placed in a waiting queue",
         "It is placed in the ready queue",
         "It is placed in the Job queue"
      ],
      "a": [
         "It is placed in an I/O queue"
      ]
   },
   {
      "q": "When a process terminates:",
      "c": [
         "It is removed from all queues",
         "It is removed from all, but the job queue",
         "Its process control block is de-allocated",
         "Its process control block is never de-allocated"
      ],
      "a": [
         "It is removed from all queues"
      ]
   },
   {
      "q": "What is a long-term scheduler?",
      "c": [
         "It selects which process has to be brought into the ready queue",
         "It selects which process has to be executed next and allocates CPU",
         "It selects which process to remove from memory by swapping",
         "None of the mentioned"
      ],
      "a": [
         "It selects which process has to be brought into the ready queue"
      ]
   },
   {
      "q": "What is a medium-term scheduler?",
      "c": [
         "It selects which process has to be brought into the ready queue",
         "It selects which process has to be executed next and allocates CPU",
         "It selects which process to remove from memory by swapping",
         "None of the mentioned"
      ],
      "a": [
         "It selects which process to remove from memory by swapping"
      ]
   },
   {
      "q": "What is a short-term scheduler?",
      "c": [
         "It selects which process has to be brought into the ready queue",
         "It selects which process has to be executed next and allocates CPU",
         "It selects which process to remove from memory by swapping",
         "None of the mentioned"
      ],
      "a": [
         "It selects which process has to be executed next and allocates CPU"
      ]
   },
   {
      "q": "The primary distinction between the short term scheduler and the long term scheduler is:",
      "c": [
         "The length of their queues",
         "The type of processes they schedule",
         "The frequency of their execution",
         "None of the mentioned"
      ],
      "a": [
         "The frequency of their execution"
      ]
   },
   {
      "q": "The only state transition that is initiated by the user process itself is:",
      "c": [
         "block",
         "wakeup",
         "dispatch",
         "none of the mentioned"
      ],
      "a": [
         "block"
      ]
   },
   {
      "q": "In a time-sharing operating system, when the time slot given to a process is completed, the process goes from the running state to the:",
      "c": [
         "Blocked state",
         "Ready state",
         "Suspended state",
         "Terminated state"
      ],
      "a": [
         "Ready state"
      ]
   },
   {
      "q": "In a multiprogramming environment:",
      "c": [
         "the processor executes more than one process at a time",
         "the programs are developed by more than one person",
         "more than one process resides in the memory",
         "a single user can execute many programs at the same time"
      ],
      "a": [
         "more than one process resides in the memory"
      ]
   },
   {
      "q": "Suppose that a process is in \u201cBlocked\u201d state waiting for some I/O service. When the service is completed, it goes to the:",
      "c": [
         "Running state",
         "Ready state",
         "Suspended state",
         "Terminated state"
      ],
      "a": [
         "Ready state"
      ]
   },
   {
      "q": "The context of a process in the PCB of a process does not contain:",
      "c": [
         "the value of the CPU registers",
         "the process state",
         "memory-management information",
         "context switch time"
      ],
      "a": [
         "context switch time"
      ]
   },
   {
      "q": "Which of the following need not necessarily be saved on a context switch between processes?",
      "c": [
         "General purpose registers",
         "Translation lookaside buffer",
         "Program counter",
         "All of the mentioned"
      ],
      "a": [
         "Translation lookaside buffer"
      ]
   },
   {
      "q": "Which of the following does not interrupt a running process?",
      "c": [
         "A device",
         "Timer",
         "Scheduler process",
         "Power failure"
      ],
      "a": [
         "Scheduler process"
      ]
   },
   {
      "q": "Which process can be affected by other processes executing in the system?",
      "c": [
         "cooperating process",
         "child process",
         "parent process",
         "init process"
      ],
      "a": [
         "cooperating process"
      ]
   },
   {
      "q": "When several processes access the same data concurrently and the outcome of the execution depends on the particular order in which the access takes place, is called:",
      "c": [
         "dynamic condition",
         "race condition",
         "essential condition",
         "critical condition"
      ],
      "a": [
         "race condition"
      ]
   },
   {
      "q": "If a process is executing in its critical section, then no other processes can be executing in their critical section. This condition is called:",
      "c": [
         "mutual exclusion",
         "critical exclusion",
         "synchronous exclusion",
         "asynchronous exclusion"
      ],
      "a": [
         "mutual exclusion"
      ]
   },
   {
      "q": "Which one of the following is a synchronization tool?",
      "c": [
         "thread",
         "pipe",
         "semaphore",
         "socket"
      ],
      "a": [
         "semaphore"
      ]
   },
   {
      "q": "A semaphore is a shared integer variable:",
      "c": [
         "that can not drop below zero",
         "that can not be more than zero",
         "that can not drop below one",
         "that can not be more than one"
      ],
      "a": [
         "that can not drop below zero"
      ]
   },
   {
      "q": "Mutual exclusion can be provided by the:",
      "c": [
         "mutex locks",
         "binary semaphores",
         "both mutex locks and binary semaphores",
         "none of the mentioned"
      ],
      "a": [
         "both mutex locks and binary semaphores"
      ]
   },
   {
      "q": "When high priority task is indirectly preempted by medium priority task effectively inverting the relative priority of the two tasks, the scenario is called",
      "c": [
         "priority inversion",
         "priority removal",
         "priority exchange",
         "priority modification"
      ],
      "a": [
         "priority inversion"
      ]
   },
   {
      "q": "Process synchronization can be done on:",
      "c": [
         "hardware level",
         "software level",
         "both hardware and software level",
         "none of the mentioned"
      ],
      "a": [
         "both hardware and software level"
      ]
   },
   {
      "q": "To enable a process to wait within the monitor:",
      "c": [
         "a condition variable must be declared as condition",
         "condition variables must be used as boolean objects",
         "semaphore must be used",
         "all of the mentioned"
      ],
      "a": [
         "a condition variable must be declared as condition"
      ]
   },
   {
      "q": "Restricting the child process to a subset of the parent\u2019s resources prevents any process from:",
      "c": [
         "overloading the system by using a lot of secondary storage",
         "under-loading the system by very less CPU utilization",
         "overloading the system by creating a lot of sub-processes",
         "crashing the system by utilizing multiple resources"
      ],
      "a": [
         "overloading the system by creating a lot of sub-processes"
      ]
   },
   {
      "q": "A parent process calling --?-- system call will be suspended until children processes terminate.",
      "c": [
         "wait",
         "fork",
         "exit",
         "exec"
      ],
      "a": [
         "wait"
      ]
   },
   {
      "q": "Cascading termination refers to termination of all child processes before the parent terminates:",
      "c": [
         "Normally",
         "Abnormally",
         "Normally or abnormally",
         "None of the mentioned"
      ],
      "a": [
         "Normally"
      ]
   },
   {
      "q": "In UNIX, each process is identified by its:",
      "c": [
         "Process Control Block",
         "Device Queue",
         "Process Identifier",
         "None of the the mentioned"
      ],
      "a": [
         "Process Identifier"
      ]
   },
   {
      "q": "In UNIX, the return value for the fork system call is --?-- for the child process and --?-- for the parent process.",
      "c": [
         "A Negative integer, Zero",
         "Zero, A Negative integer",
         "Zero, A nonzero integer",
         "A nonzero integer, Zero"
      ],
      "a": [
         "Zero, A nonzero integer"
      ]
   },
   {
      "q": "The child process can:",
      "c": [
         "be a duplicate of the parent process",
         "never be a duplicate of the parent process",
         "cannot have another program loaded into it",
         "never have another program loaded into it"
      ],
      "a": [
         "be a duplicate of the parent process"
      ]
   },
   {
      "q": "The child process completes execution,but the parent keeps executing, then the child process is known as:",
      "c": [
         "Orphan",
         "Zombie",
         "Body",
         "Dead"
      ],
      "a": [
         "Zombie"
      ]
   },
   {
      "q": "Inter process communication:",
      "c": [
         "allows processes to communicate and synchronize their actions when using the same address space",
         "allows processes to communicate and synchronize their actions without using the same address space",
         "allows the processes to only synchronize their actions without communication",
         "none of the mentioned"
      ],
      "a": [
         "allows processes to communicate and synchronize their actions without using the same address space"
      ]
   },
   {
      "q": "Message passing system allows processes to:",
      "c": [
         "communicate with one another without resorting to shared data",
         "communicate with one another by resorting to shared data",
         "share data",
         "name the recipient or sender of the message"
      ],
      "a": [
         "communicate with one another without resorting to shared data"
      ]
   },
   {
      "q": "An IPC facility provides at least two operations:",
      "c": [
         "write & delete message",
         "delete & receive message",
         "send & delete message",
         "receive & send message"
      ],
      "a": [
         "receive & send message"
      ]
   },
   {
      "q": "Messages sent by a process:",
      "c": [
         "have to be of a fixed size",
         "have to be a variable size",
         "can be fixed or variable sized",
         "None of the mentioned"
      ],
      "a": [
         "can be fixed or variable sized"
      ]
   },
   {
      "q": "In the non blocking send:",
      "c": [
         "the sending process keeps sending until the message is received",
         "the sending process sends the message and resumes operation",
         "the sending process keeps sending until it receives a message",
         "none of the mentioned"
      ],
      "a": [
         "the sending process sends the message and resumes operation"
      ]
   },
   {
      "q": "In the Zero capacity queue:",
      "c": [
         "the queue can store at least one message",
         "the sender blocks until the receiver receives the message",
         "the sender keeps sending and the messages don\u2019t wait in the queue",
         "none of the mentioned"
      ],
      "a": [
         "the sender blocks until the receiver receives the message"
      ]
   },
   {
      "q": "The Zero Capacity queue:",
      "c": [
         "is referred to as a message system with buffering",
         "is referred to as a message system with no buffering",
         "is referred to as a link",
         "none of the mentioned"
      ],
      "a": [
         "is referred to as a message system with no buffering"
      ]
   },
   {
      "q": "Bounded capacity and Unbounded capacity queues are referred to as:",
      "c": [
         "Programmed buffering",
         "Automatic buffering",
         "User defined buffering",
         "No buffering"
      ],
      "a": [
         "Automatic buffering"
      ]
   },
   {
      "q": "Remote Procedure Calls are used:",
      "c": [
         "for communication between two processes remotely different from each other on the same system",
         "for communication between two processes on the same system",
         "for communication between two processes on separate systems",
         "None of the mentioned"
      ],
      "a": [
         "for communication between two processes on separate systems"
      ]
   },
   {
      "q": "To differentiate the many network services a system supports --?-- are used.",
      "c": [
         "Variables",
         "Sockets",
         "Ports",
         "Service names"
      ],
      "a": [
         "Ports"
      ]
   },
   {
      "q": "RPC provides a(an) --?-- on the client side, a separate one for each remote procedure.",
      "c": [
         "stub",
         "identifier",
         "name",
         "process identifier"
      ],
      "a": [
         "stub"
      ]
   },
   {
      "q": "The stub provided by an RPC:",
      "c": [
         "transmits the message to the server where the server side stub receives the message and invokes procedure on the server side",
         "packs the parameters into a form transmittable over the network",
         "locates the port on the server",
         "all of the mentioned"
      ],
      "a": [
         "all of the mentioned"
      ]
   },
   {
      "q": "To resolve the problem of data representation on different systems RPCs define:",
      "c": [
         "machine dependent representation of data",
         "machine representation of data",
         "machine-independent representation of data",
         "none of the mentioned"
      ],
      "a": [
         "machine-independent representation of data"
      ]
   },
   {
      "q": "A process that is based on IPC mechanism which executes on different systems and can communicate with other processes using message based communication, is called ________",
      "c": [
         "Local Procedure Call",
         "Inter Process Communication",
         "Remote Procedure Call",
         "Remote Machine Invocation"
      ],
      "a": [
         "Remote Procedure Call"
      ]
   },
   {
      "q": "The initial program that is run when the computer is powered up is called:",
      "c": [
         "boot program",
         "bootloader",
         "initializer",
         "bootstrap program"
      ],
      "a": [
         "bootstrap program"
      ]
   },
   {
      "q": "How does the software trigger an interrupt?",
      "c": [
         "Sending signals to CPU through bus",
         "Executing a special operation called system call",
         "Executing a special program called system program",
         "Executing a special program calle interrupt trigger program"
      ],
      "a": [
         "Executing a special operation called system call"
      ]
   },
   {
      "q": "What is a trap/exception?",
      "c": [
         "hardware generated interrupt caused by an error",
         "software generated interrupt caused by an error",
         "user generated interrupt caused by an error",
         "none of the mentioned"
      ],
      "a": [
         "software generated interrupt caused by an error"
      ]
   },
   {
      "q": "An interrupt vector:",
      "c": [
         "is an address that is indexed to an interrupt handler",
         "is a unique device number that is indexed by an address",
         "is a unique identity given to an interrupt",
         "none of the mentioned"
      ],
      "a": [
         "is an address that is indexed to an interrupt handler"
      ]
   },
   {
      "q": "DMA is used for:",
      "c": [
         "High speed devices(disks and communications network)",
         "Low speed devices",
         "Utilizing CPU cycles",
         "All of the mentioned"
      ],
      "a": [
         "High speed devices(disks and communications network)"
      ]
   },
   {
      "q": "In a memory mapped input/output:",
      "c": [
         "the CPU uses polling to watch the control bit constantly, looping to see if device is ready",
         "the CPU writes one data byte to the data register and sets a bit in control register to show that a byte is available",
         "the CPU receives an interrupt when the device is ready for the next byte",
         "the CPU runs a user written code and does accordingly"
      ],
      "a": [
         "the CPU writes one data byte to the data register and sets a bit in control register to show that a byte is available"
      ]
   },
   {
      "q": "In a programmed input/output(PIO):",
      "c": [
         "the CPU uses polling to watch the control bit constantly, looping to see if device is ready",
         "the CPU writes one data byte to the data register and sets a bit in control register to show that a byte is available",
         "the CPU receives an interrupt when the device is ready for the next byte",
         "the CPU runs a user written code and does accordingly"
      ],
      "a": [
         "the CPU uses polling to watch the control bit constantly, looping to see if device is ready"
      ]
   },
   {
      "q": "In an interrupt driven input/output:",
      "c": [
         "the CPU uses polling to watch the control bit constantly, looping to see if device is ready",
         "the CPU writes one data byte to the data register and sets a bit in control register to show that a byte is available",
         "the CPU receives an interrupt when the device is ready for the next byte",
         "the CPU runs a user written code and does accordingly"
      ],
      "a": [
         "the CPU receives an interrupt when the device is ready for the next byte"
      ]
   },
   {
      "q": "In the layered approach of Operating Systems:",
      "c": [
         "Bottom Layer(0) is the User interface",
         "Highest Layer(N) is the User interface",
         "Bottom Layer(N) is the hardware",
         "Highest Layer(N) is the hardware"
      ],
      "a": [
         "Highest Layer(N) is the User interface"
      ]
   },
   {
      "q": "How does the Hardware trigger an interrupt?",
      "c": [
         "Sending signals to CPU through system bus",
         "Executing a special program called interrupt program",
         "Executing a special program called system program",
         "Executing a special operation called system call"
      ],
      "a": [
         "Sending signals to CPU through system bus"
      ]
   },
   {
      "q": "Which operation is performed by an interrupt handler?",
      "c": [
         "Saving the current state of the system",
         "Loading the interrupt handling code and executing it",
         "Once done handling, bringing back the system to the original state it was before the interrupt occurred",
         "All of the mentioned"
      ],
      "a": [
         "All of the mentioned"
      ]
   },
   {
      "q": "Which module gives control of the CPU to the process selected by the short-term scheduler?",
      "c": [
         "dispatcher",
         "interrupt",
         "scheduler",
         "none of the mentioned"
      ],
      "a": [
         "dispatcher"
      ]
   },
   {
      "q": "The processes that are residing in main memory and are ready and waiting to execute are kept on a list called:",
      "c": [
         "job queue",
         "ready queue",
         "execution queue",
         "process queue"
      ],
      "a": [
         "ready queue"
      ]
   },
   {
      "q": "The interval from the time of submission of a process to the time of completion is termed as:",
      "c": [
         "waiting time",
         "turnaround time",
         "response time",
         "throughput"
      ],
      "a": [
         "turnaround time"
      ]
   },
   {
      "q": "In priority scheduling algorithm, when a process arrives at the ready queue, its priority is compared with the priority of:",
      "c": [
         "all process",
         "currently running process",
         "parent process",
         "init process"
      ],
      "a": [
         "currently running process"
      ]
   },
   {
      "q": "Time quantum is defined in:",
      "c": [
         "shortest job scheduling algorithm",
         "round robin scheduling algorithm",
         "priority scheduling algorithm",
         "multilevel queue scheduling algorithm"
      ],
      "a": [
         "round robin scheduling algorithm"
      ]
   },
   {
      "q": "Which one of the following can not be scheduled by the kernel?",
      "c": [
         "kernel level thread",
         "user level thread",
         "process",
         "none of the mentioned"
      ],
      "a": [
         "user level thread"
      ]
   },
   {
      "q": "CPU scheduling is the basis of:",
      "c": [
         "multiprocessor systems",
         "multiprogramming operating systems",
         "larger memory sized systems",
         "none of the mentioned"
      ],
      "a": [
         "multiprogramming operating systems"
      ]
   },
   {
      "q": "The two steps of a process execution are:",
      "c": [
         "I/O & OS Burst",
         "CPU & I/O Burst",
         "Memory & I/O Burst",
         "OS & Memory Burst"
      ],
      "a": [
         "CPU & I/O Burst"
      ]
   },
   {
      "q": "An I/O bound program will typically have:",
      "c": [
         "a few very short CPU bursts",
         "many very short I/O bursts",
         "many very short CPU bursts",
         "a few very short I/O bursts"
      ],
      "a": [
         "many very short CPU bursts"
      ]
   },
   {
      "q": "A process is selected from the --?-- queue by the --?-- scheduler, to be executed.",
      "c": [
         "blocked, short term",
         "wait, long term",
         "ready, short term",
         "ready, long term"
      ],
      "a": [
         "ready, short term"
      ]
   },
   {
      "q": "In the following cases non \u2013 preemptive scheduling occurs:",
      "c": [
         "When a process switches from the running state to the ready state",
         "When a process goes from the running state to the waiting state",
         "When a process switches from the waiting state to the ready state",
         "All of the mentioned"
      ],
      "a": [
         "When a process goes from the running state to the waiting state"
      ]
   },
   {
      "q": "The switching of the CPU from one process or thread to another is called:",
      "c": [
         "process switch",
         "task switch",
         "context switch",
         "all of the mentioned"
      ],
      "a": [
         "all of the mentioned"
      ]
   },
   {
      "q": "Dispatch latency is:",
      "c": [
         "the speed of dispatching a process from running to the ready state",
         "the time of dispatching a process from running to ready state and keeping the CPU idle",
         "the time to stop one process and start running another one",
         "none of the mentioned"
      ],
      "a": [
         "the time to stop one process and start running another one"
      ]
   },
   {
      "q": "Scheduling is done so as to:",
      "c": [
         "increase CPU utilization",
         "decrease CPU utilization",
         "keep the CPU more idle",
         "None of the mentioned"
      ],
      "a": [
         "increase CPU utilization"
      ]
   },
   {
      "q": "Scheduling is done so as to:",
      "c": [
         "increase the throughput",
         "decrease the throughput",
         "increase the duration of a specific amount of work",
         "None of the mentioned"
      ],
      "a": [
         "increase the throughput"
      ]
   },
   {
      "q": "Turnaround time is:",
      "c": [
         "the total waiting time for a process to finish execution",
         "the total time spent in the ready queue",
         "the total time spent in the running queue",
         "the total time from the completion till the submission of a process"
      ],
      "a": [
         "the total time from the completion till the submission of a process"
      ]
   },
   {
      "q": "Scheduling is done so as to:",
      "c": [
         "increase the turnaround time",
         "decrease the turnaround time",
         "keep the turnaround time same",
         "there is no relation between scheduling and turnaround time"
      ],
      "a": [
         "decrease the turnaround time"
      ]
   },
   {
      "q": "Waiting time is:",
      "c": [
         "the total time in the blocked and waiting queues",
         "the total time spent in the ready queue",
         "the total time spent in the running queue",
         "the total time from the completion till the submission of a process"
      ],
      "a": [
         "the total time spent in the ready queue"
      ]
   },
   {
      "q": "Scheduling is done so as to:",
      "c": [
         "increase the waiting time",
         "keep the waiting time the same",
         "decrease the waiting time",
         "none of the mentioned"
      ],
      "a": [
         "decrease the waiting time"
      ]
   },
   {
      "q": "Response time is:",
      "c": [
         "the total time taken from the submission time till the completion time",
         "the total time taken from the submission time till the first response is produced",
         "the total time taken from submission time till the response is output",
         "none of the mentioned"
      ],
      "a": [
         "the total time taken from the submission time till the first response is produced"
      ]
   },
   {
      "q": "Round robin scheduling falls under the category of:",
      "c": [
         "Non preemptive scheduling",
         "Preemptive scheduling",
         "All of the mentioned",
         "None of the mentioned"
      ],
      "a": [
         "Preemptive scheduling"
      ]
   },
   {
      "q": "With round robin scheduling algorithm in a time shared system:",
      "c": [
         "using very large time slices converts it into First come First served scheduling algorithm",
         "using very small time slices converts it into First come First served scheduling algorithm",
         "using extremely small time slices increases performance",
         "using very small time slices converts it into Shortest Job First algorithm"
      ],
      "a": [
         "using very large time slices converts it into First come First served scheduling algorithm"
      ]
   },
   {
      "q": "The portion of the process scheduler in an operating system that dispatches processes is concerned with:",
      "c": [
         "assigning ready processes to CPU",
         "assigning ready processes to waiting queue",
         "assigning running processes to blocked queue",
         "all of the mentioned"
      ],
      "a": [
         "assigning ready processes to CPU"
      ]
   },
   {
      "q": "The strategy of making processes that are logically runnable to be temporarily suspended is called:",
      "c": [
         "Non preemptive scheduling",
         "Preemptive scheduling",
         "Shortest job first",
         "First come First served"
      ],
      "a": [
         "Preemptive scheduling"
      ]
   },
   {
      "q": "Scheduling is:",
      "c": [
         "allowing a job to use the processor",
         "making proper use of processor",
         "all of the mentioned",
         "none of the mentioned"
      ],
      "a": [
         "allowing a job to use the processor"
      ]
   },
   {
      "q": "Which of the following algorithms tends to minimize the process flow time?",
      "c": [
         "First come First served",
         "Shortest Job First",
         "Earliest Deadline First",
         "Longest Job First"
      ],
      "a": [
         "Shortest Job First"
      ]
   },
   {
      "q": "Under multiprogramming, turnaround time for short jobs is usually --?-- and that for long jobs is slightly --?--",
      "c": [
         "Lengthened; Shortened",
         "Shortened; Lengthened",
         "Shortened; Shortened",
         "Shortened; Unchanged"
      ],
      "a": [
         "Shortened; Lengthened"
      ]
   },
   {
      "q": "The real difficulty with SJF in short term scheduling is:",
      "c": [
         "it is too good an algorithm",
         "knowing the length of the next CPU request",
         "it is too complex to understand",
         "none of the mentioned"
      ],
      "a": [
         "knowing the length of the next CPU request"
      ]
   },
   {
      "q": "The FCFS algorithm is particularly troublesome for:",
      "c": [
         "time sharing systems",
         "multiprogramming systems",
         "multiprocessor systems",
         "operating systems"
      ],
      "a": [
         "multiprogramming systems"
      ]
   },
   {
      "q": "An SJF algorithm is simply a priority algorithm where the priority is:",
      "c": [
         "the predicted next CPU burst",
         "the inverse of the predicted next CPU burst",
         "the current CPU burst",
         "anything the user wants"
      ],
      "a": [
         "the predicted next CPU burst"
      ]
   },
   {
      "q": "One of the disadvantages of the priority scheduling algorithm is that:",
      "c": [
         "it schedules in a very complex manner",
         "its scheduling takes up a lot of time",
         "it can lead to some low priority process waiting indefinitely for the CPU",
         "none of the mentioned"
      ],
      "a": [
         "it can lead to some low priority process waiting indefinitely for the CPU"
      ]
   },
   {
      "q": "\u2018Aging\u2019 is:",
      "c": [
         "keeping track of cache contents",
         "keeping track of what pages are currently residing in memory",
         "keeping track of how many times a given page is referenced",
         "increasing the priority of jobs to ensure termination in a finite time"
      ],
      "a": [
         "increasing the priority of jobs to ensure termination in a finite time"
      ]
   },
   {
      "q": "A solution to the problem of indefinite blockage of low \u2013 priority processes is:",
      "c": [
         "Starvation",
         "Wait queue",
         "Ready queue",
         "Aging"
      ],
      "a": [
         "Aging"
      ]
   },
   {
      "q": "Which of the following scheduling algorithms gives minimum average waiting time?",
      "c": [
         "FCFS",
         "SJF",
         "Round \u2013 robin",
         "Priority"
      ],
      "a": [
         "SJF"
      ]
   },
   {
      "q": "Concurrent access to shared data may result in:",
      "c": [
         "data consistency",
         "data insecurity",
         "data inconsistency",
         "none of the mentioned"
      ],
      "a": [
         "data inconsistency"
      ]
   },
   {
      "q": "A situation where several processes access and manipulate the same data concurrently and the outcome of the execution depends on the particular order in which access takes place is called:",
      "c": [
         "data consistency",
         "race condition",
         "aging",
         "starvation"
      ],
      "a": [
         "race condition"
      ]
   },
   {
      "q": "The segment of code in which the process may change common variables, update tables, write into files is known as:",
      "c": [
         "program",
         "critical section",
         "non \u2013 critical section",
         "synchronizing"
      ],
      "a": [
         "critical section"
      ]
   },
   {
      "q": "The following three conditions must be satisfied to solve the critical section problem:",
      "c": [
         "Mutual Exclusion",
         "Progress",
         "Bounded Waiting",
         "All of the mentioned"
      ],
      "a": [
         "All of the mentioned"
      ]
   },
   {
      "q": "Mutual exclusion implies that:",
      "c": [
         "if a process is executing in its critical section, then no other process must be executing in their critical sections",
         "if a process is executing in its critical section, then other processes must be executing in their critical sections",
         "if a process is executing in its critical section, then all the resources of the system must be blocked until it finishes execution",
         "none of the mentioned"
      ],
      "a": [
         "if a process is executing in its critical section, then no other process must be executing in their critical sections"
      ]
   },
   {
      "q": "Bounded waiting implies that there exists a bound on the number of times a process is allowed to enter its critical section:",
      "c": [
         "after a process has made a request to enter its critical section and before the request is granted",
         "when another process is in its critical section",
         "before a process has made a request to enter its critical section",
         "none of the mentioned"
      ],
      "a": [
         "after a process has made a request to enter its critical section and before the request is granted"
      ]
   },
   {
      "q": "In the bakery algorithm to solve the critical section problem:",
      "c": [
         "each process is put into a queue and picked up in an ordered manner",
         "each process receives a number (may or may not be unique) and the one with the lowest number is served next",
         "each process gets a unique number and the one with the highest number is served next",
         "each process gets a unique number and the one with the lowest number is served next"
      ],
      "a": [
         "each process receives a number (may or may not be unique) and the one with the lowest number is served next"
      ]
   },
   {
      "q": "Semaphore is a/an --?-- to solve the critical section problem.",
      "c": [
         "hardware for a system",
         "special program for a system",
         "integer variable",
         "none of the mentioned"
      ],
      "a": [
         "integer variable"
      ]
   },
   {
      "q": "The atomic operation permissible on semaphores are:",
      "c": [
         "wait",
         "stop",
         "hold",
         "none of the mentioned"
      ],
      "a": [
         "wait"
      ]
   },
   {
      "q": "Spinlocks are:",
      "c": [
         "CPU cycles wasting locks over critical sections of programs",
         "Locks that avoid time wastage in context switches",
         "Locks that work better on multiprocessor systems",
         "All of the mentioned"
      ],
      "a": [
         "All of the mentioned"
      ]
   },
   {
      "q": "The main disadvantage of spinlocks is that:",
      "c": [
         "they are not sufficient for many process",
         "they require busy waiting",
         "they are unreliable sometimes",
         "they are too complex for programmers"
      ],
      "a": [
         "they require busy waiting"
      ]
   },
   {
      "q": "The wait operation of the semaphore basically works on the basic --?-- system call.",
      "c": [
         "stop()",
         "block()",
         "hold()",
         "wait()"
      ],
      "a": [
         "block()"
      ]
   },
   {
      "q": "The signal operation of the semaphore basically works on the basic --?-- system call.",
      "c": [
         "continue()",
         "wakeup()",
         "getup()",
         "start()"
      ],
      "a": [
         "wakeup()"
      ]
   },
   {
      "q": "If the semaphore value is negative:",
      "c": [
         "its magnitude is the number of processes waiting on that semaphore",
         "it is invalid",
         "no operation can be further performed on it until the signal operation is performed on it",
         "none of the mentioned"
      ],
      "a": [
         "its magnitude is the number of processes waiting on that semaphore"
      ]
   },
   {
      "q": "The code that changes the value of the semaphore is:",
      "c": [
         "remainder section code",
         "non \u2013 critical section code",
         "critical section code",
         "none of the mentioned"
      ],
      "a": [
         "critical section code"
      ]
   },
   {
      "q": "What will happen if a non-recursive mutex is locked more than once?",
      "c": [
         "Starvation",
         "Deadlock",
         "Aging",
         "Signaling"
      ],
      "a": [
         "Deadlock"
      ]
   },
   {
      "q": "A semaphore:",
      "c": [
         "is a binary mutex",
         "must be accessed from only one process",
         "can be accessed from multiple processes",
         "none of the mentioned"
      ],
      "a": [
         "can be accessed from multiple processes"
      ]
   },
   {
      "q": "The two kinds of semaphores are:",
      "c": [
         "mutex & counting",
         "binary & counting",
         "counting & decimal",
         "decimal & binary"
      ],
      "a": [
         "binary & counting"
      ]
   },
   {
      "q": "A mutex:",
      "c": [
         "is a binary mutex",
         "must be accessed from only one process",
         "can be accessed from multiple processes",
         "None of the mentioned"
      ],
      "a": [
         "must be accessed from only one process"
      ]
   },
   {
      "q": "Semaphores are mostly used to implement:",
      "c": [
         "System calls",
         "IPC mechanisms",
         "System protection",
         "None of the mentioned"
      ],
      "a": [
         "IPC mechanisms"
      ]
   },
   {
      "q": "Spinlocks are intended to provide --?-- only.",
      "c": [
         "Mutual Exclusion",
         "Bounded Waiting",
         "Aging",
         "Progress"
      ],
      "a": [
         "Bounded Waiting"
      ]
   },
   {
      "q": "The bounded buffer problem is also known as:",
      "c": [
         "Readers \u2013 Writers problem",
         "Dining \u2013 Philosophers problem",
         "Producer \u2013 Consumer problem",
         "None of the mentioned"
      ],
      "a": [
         "Producer \u2013 Consumer problem"
      ]
   },
   {
      "q": "In the bounded buffer problem, there are the empty and full semaphores that:",
      "c": [
         "count the number of empty and full buffers",
         "count the number of empty and full memory spaces",
         "count the number of empty and full queues",
         "none of the mentioned"
      ],
      "a": [
         "count the number of empty and full buffers"
      ]
   },
   {
      "q": "A deadlock free solution to the dining philosophers problem:",
      "c": [
         "necessarily eliminates the possibility of starvation",
         "does not necessarily eliminate the possibility of starvation",
         "eliminates any possibility of any kind of problem further",
         "none of the mentioned"
      ],
      "a": [
         "does not necessarily eliminate the possibility of starvation"
      ]
   },
   {
      "q": "A monitor is a type of:",
      "c": [
         "semaphore",
         "low level synchronization construct",
         "high level synchronization construct",
         "none of the mentioned"
      ],
      "a": [
         "high level synchronization construct"
      ]
   },
   {
      "q": "A monitor is characterized by:",
      "c": [
         "a set of programmer defined operators",
         "an identifier",
         "the number of variables in it",
         "all of the mentioned"
      ],
      "a": [
         "a set of programmer defined operators"
      ]
   },
   {
      "q": "The monitor construct ensures that:",
      "c": [
         "only one process can be active at a time within the monitor",
         "n number of processes can be active at a time within the monitor (n being greater than 1)",
         "the queue has only one process in it at a time",
         "all of the mentioned"
      ],
      "a": [
         "only one process can be active at a time within the monitor"
      ]
   },
   {
      "q": "The operations that can be invoked on a condition variable are:",
      "c": [
         "wait & signal",
         "hold & wait",
         "signal & hold",
         "continue & signal"
      ],
      "a": [
         "wait & signal"
      ]
   },
   {
      "q": "The process invoking the wait operation is:",
      "c": [
         "suspended until another process invokes the signal operation",
         "waiting for another process to complete before it can itself call the signal operation",
         "stopped until the next process in the queue finishes execution",
         "none of the mentioned"
      ],
      "a": [
         "suspended until another process invokes the signal operation"
      ]
   },
   {
      "q": "If no process is suspended, the signal operation:",
      "c": [
         "puts the system into a deadlock state",
         "suspends some default process\u2019 execution",
         "nothing happens",
         "the output is unpredictable"
      ],
      "a": [
         "nothing happens"
      ]
   },
   {
      "q": "A collection of instructions that performs a single logical function is called:",
      "c": [
         "transaction",
         "operation",
         "function",
         "all of the mentioned"
      ],
      "a": [
         "transaction"
      ]
   },
   {
      "q": "A terminated transaction that has completed its execution successfully is --?-- otherwise it is --?--",
      "c": [
         "committed, destroyed",
         "aborted, destroyed",
         "committed, aborted",
         "none of the mentioned"
      ],
      "a": [
         "committed, aborted"
      ]
   },
   {
      "q": "The state of the data accessed by an aborted transaction must be restored to what it was just before the transaction started executing. This restoration is known as ________ of transaction.",
      "c": [
         "safety",
         "protection",
         "roll \u2013 back",
         "revert \u2013 back"
      ],
      "a": [
         "roll \u2013 back"
      ]
   },
   {
      "q": "Write ahead logging is a way:",
      "c": [
         "to ensure atomicity",
         "to keep data consistent",
         "that records data on stable storage",
         "all of the mentioned"
      ],
      "a": [
         "all of the mentioned"
      ]
   },
   {
      "q": "An actual update is not allowed to a data item:",
      "c": [
         "before the corresponding log record is written out to stable storage",
         "after the corresponding log record is written out to stable storage",
         "until the whole log record has been checked for inconsistencies",
         "all of the mentioned"
      ],
      "a": [
         "before the corresponding log record is written out to stable storage"
      ]
   },
   {
      "q": "The undo and redo operations must be --?-- to guarantee correct behaviour, even if a failure occurs during recovery process.",
      "c": [
         "idempotent",
         "easy",
         "protected",
         "all of the mentioned"
      ],
      "a": [
         "idempotent"
      ]
   },
   {
      "q": "The system periodically performs checkpoints that consists of the following operation(s):",
      "c": [
         "Putting all the log records currently in main memory onto stable storage",
         "putting all modified data residing in main memory onto stable storage",
         "putting a log record onto stable storage",
         "all of the mentioned"
      ],
      "a": [
         "all of the mentioned"
      ]
   },
   {
      "q": "The two phase locking protocol consists of:",
      "c": [
         "growing & shrinking phase",
         "shrinking & creation phase",
         "creation & growing phase",
         "destruction & creation phase"
      ],
      "a": [
         "growing & shrinking phase"
      ]
   },
   {
      "q": "The growing phase is a phase in which:",
      "c": [
         "A transaction may obtain locks, but does not release any",
         "A transaction may obtain locks, and releases a few or all of them",
         "A transaction may release locks, but does not obtain any new locks",
         "A transaction may release locks, and does obtain new locks"
      ],
      "a": [
         "A transaction may obtain locks, but does not release any"
      ]
   },
   {
      "q": "The shrinking phase is a phase in which:",
      "c": [
         "A transaction may obtain locks, but does not release any",
         "A transaction may obtain locks, and releases a few or all of them",
         "A transaction may release locks, but does not obtain any new locks",
         "A transaction may release locks, and obtains new locks"
      ],
      "a": [
         "A transaction may release locks, but does not obtain any new locks"
      ]
   },
   {
      "q": "A system is in the safe state if:",
      "c": [
         "the system can allocate resources to each process in some order and still avoid a deadlock",
         "there exist a safe sequence",
         "all of the mentioned",
         "none of the mentioned"
      ],
      "a": [
         "the system can allocate resources to each process in some order and still avoid a deadlock"
      ]
   },
   {
      "q": "The circular wait condition can be prevented by:",
      "c": [
         "defining a linear ordering of resource types",
         "using thread",
         "using pipes",
         "all of the mentioned"
      ],
      "a": [
         "defining a linear ordering of resource types"
      ]
   },
   {
      "q": "Which one of the following is the deadlock avoidance algorithm?",
      "c": [
         "banker\u2019s algorithm",
         "round-robin algorithm",
         "elevator algorithm",
         "karn\u2019s algorithm"
      ],
      "a": [
         "banker\u2019s algorithm"
      ]
   },
   {
      "q": "What is the drawback of banker\u2019s algorithm?",
      "c": [
         "in advance processes rarely know that how much resource they will need",
         "the number of processes changes as time progresses",
         "resource once available can disappear",
         "all of the mentioned"
      ],
      "a": [
         "all of the mentioned"
      ]
   },
   {
      "q": "For effective operating system, when to check for deadlock?",
      "c": [
         "every time a resource request is made",
         "at fixed time intervals",
         "every time a resource request is made at fixed time intervals",
         "none of the mentioned"
      ],
      "a": [
         "every time a resource request is made at fixed time intervals"
      ]
   },
   {
      "q": "A problem encountered in multitasking when a process is perpetually denied necessary resources is called:",
      "c": [
         "deadlock",
         "starvation",
         "inversion",
         "aging"
      ],
      "a": [
         "starvation"
      ]
   },
   {
      "q": "Which one of the following is a visual ( mathematical ) way to determine the deadlock occurrence?",
      "c": [
         "resource allocation graph",
         "starvation graph",
         "inversion graph",
         "none of the mentioned"
      ],
      "a": [
         "resource allocation graph"
      ]
   },
   {
      "q": "To avoid deadlock:",
      "c": [
         "there must be a fixed number of resources to allocate",
         "resource allocation must be done only once",
         "all deadlocked processes must be aborted",
         "inversion technique can be used"
      ],
      "a": [
         "there must be a fixed number of resources to allocate"
      ]
   },
   {
      "q": "The request and release of resources are:",
      "c": [
         "command line statements",
         "interrupts",
         "system calls",
         "special programs"
      ],
      "a": [
         "system calls"
      ]
   },
   {
      "q": "Multithreaded programs are:",
      "c": [
         "lesser prone to deadlocks",
         "more prone to deadlocks",
         "not at all prone to deadlocks",
         "none of the mentioned"
      ],
      "a": [
         "more prone to deadlocks"
      ]
   },
   {
      "q": "For a deadlock to arise, which of the following conditions must hold simultaneously?",
      "c": [
         "Mutual exclusion",
         "No preemption",
         "Hold and wait",
         "All of the mentioned"
      ],
      "a": [
         "All of the mentioned"
      ]
   },
   {
      "q": "For Mutual exclusion to prevail in the system:",
      "c": [
         "at least one resource must be held in a non sharable mode",
         "the processor must be a uniprocessor rather than a multiprocessor",
         "there must be at least one resource in a sharable mode",
         "all of the mentioned"
      ],
      "a": [
         "at least one resource must be held in a non sharable mode"
      ]
   },
   {
      "q": "For a Hold and wait condition to prevail:",
      "c": [
         "A process must be not be holding a resource, but waiting for one to be freed, and then request to acquire it",
         "A process must be holding at least one resource and waiting to acquire additional resources that are being held by other processes",
         "A process must hold at least one resource and not be waiting to acquire additional resources",
         "None of the mentioned"
      ],
      "a": [
         "A process must be holding at least one resource and waiting to acquire additional resources that are being held by other processes"
      ]
   },
   {
      "q": "Deadlock prevention is a set of methods:",
      "c": [
         "to ensure that at least one of the necessary conditions cannot hold",
         "to ensure that all of the necessary conditions do not hold",
         "to decide if the requested resources for a process have to be given or not",
         "to recover from a deadlock"
      ],
      "a": [
         "to ensure that at least one of the necessary conditions cannot hold"
      ]
   },
   {
      "q": "For non sharable resources like a printer, mutual exclusion:",
      "c": [
         "must exist",
         "must not exist",
         "may exist",
         "none of the mentioned"
      ],
      "a": [
         "must exist"
      ]
   },
   {
      "q": "For sharable resources, mutual exclusion:",
      "c": [
         "is required",
         "is not required",
         "may be or may not be required",
         "none of the mentioned"
      ],
      "a": [
         "is not required"
      ]
   },
   {
      "q": "To ensure that the hold and wait condition never occurs in the system, it must be ensured that:",
      "c": [
         "whenever a resource is requested by a process, it is not holding any other resources",
         "each process must request and be allocated all its resources before it begins its execution",
         "a process can request resources only when it has none",
         "all of the mentioned"
      ],
      "a": [
         "all of the mentioned"
      ]
   },
   {
      "q": "The disadvantage of a process being allocated all its resources before beginning its execution is:",
      "c": [
         "Low CPU utilization",
         "Low resource utilization",
         "Very high resource utilization",
         "None of the mentioned"
      ],
      "a": [
         "Low resource utilization"
      ]
   },
   {
      "q": "To ensure no preemption, if a process is holding some resources and requests another resource that cannot be immediately allocated to it:",
      "c": [
         "then the process waits for the resources be allocated to it",
         "the process keeps sending requests until the resource is allocated to it",
         "the process resumes execution without the resource being allocated to it",
         "then all resources currently being held are preempted"
      ],
      "a": [
         "then all resources currently being held are preempted"
      ]
   },
   {
      "q": "One way to ensure that the circular wait condition never holds is to:",
      "c": [
         "impose a total ordering of all resource types and to determine whether one precedes another in the ordering",
         "to never let a process acquire resources that are held by other processes",
         "to let a process wait for only one resource at a time",
         "all of the mentioned"
      ],
      "a": [
         "impose a total ordering of all resource types and to determine whether one precedes another in the ordering"
      ]
   },
   {
      "q": "Given a priori information about the --?-- number of resources of each type that maybe requested for each process, it is possible to construct an algorithm that ensures that the system will never enter a deadlock state.",
      "c": [
         "minimum",
         "average",
         "maximum",
         "approximate"
      ],
      "a": [
         "maximum"
      ]
   },
   {
      "q": "A deadlock avoidance algorithm dynamically examines the --?-- to ensure that a circular wait condition can never exist.",
      "c": [
         "resource allocation state",
         "system storage state",
         "operating system",
         "resources"
      ],
      "a": [
         "resource allocation state"
      ]
   },
   {
      "q": "A state is safe, if:",
      "c": [
         "the system does not crash due to deadlock occurrence",
         "the system can allocate resources to each process in some order and still avoid a deadlock",
         "the state keeps the system protected and safe",
         "all of the mentioned"
      ],
      "a": [
         "the system can allocate resources to each process in some order and still avoid a deadlock"
      ]
   },
   {
      "q": "If no cycle exists in the resource allocation graph:",
      "c": [
         "then the system will not be in a safe state",
         "then the system will be in a safe state",
         "all of the mentioned",
         "none of the mentioned"
      ],
      "a": [
         "then the system will be in a safe state"
      ]
   },
   {
      "q": "The resource allocation graph is not applicable to a resource allocation system:",
      "c": [
         "with multiple instances of each resource type",
         "with a single instance of each resource type",
         "single & multiple instance of each resource type",
         "none of the mentioned"
      ],
      "a": [
         "with multiple instances of each resource type"
      ]
   },
   {
      "q": "The wait-for graph is a deadlock detection algorithm that is applicable when:",
      "c": [
         "all resources have a single instance",
         "all resources have multiple instances",
         "all resources have a single 7 multiple instance",
         "all of the mentioned"
      ],
      "a": [
         "all resources have a single instance"
      ]
   },
   {
      "q": "The disadvantage of invoking the detection algorithm for every request is:",
      "c": [
         "overhead of the detection algorithm due to consumption of memory",
         "excessive time consumed in the request to be allocated memory",
         "considerable overhead in computation time",
         "all of the mentioned"
      ],
      "a": [
         "considerable overhead in computation time"
      ]
   },
   {
      "q": "Every time a request for allocation cannot be granted immediately, the detection algorithm is invoked. This will help identify:",
      "c": [
         "the set of processes that have been deadlocked",
         "the set of processes in the deadlock queue",
         "the specific process that caused the deadlock",
         "all of the mentioned"
      ],
      "a": [
         "the set of processes that have been deadlocked"
      ]
   },
   {
      "q": "A deadlock can be broken by:",
      "c": [
         "abort one or more processes to break the circular wait",
         "abort all the process in the system",
         "preempt all resources from all processes",
         "none of the mentioned"
      ],
      "a": [
         "abort one or more processes to break the circular wait"
      ]
   },
   {
      "q": "The ways of aborting processes and eliminating deadlocks are:",
      "c": [
         "Abort all deadlocked processes",
         "Abort all processes",
         "Abort one process at a time until the deadlock cycle is eliminated",
         "All of the mentioned"
      ],
      "a": [
         "Abort one process at a time until the deadlock cycle is eliminated"
      ]
   },
   {
      "q": "Those processes should be aborted on occurrence of a deadlock, the termination of which:",
      "c": [
         "is more time consuming",
         "incurs minimum cost",
         "safety is not hampered",
         "all of the mentioned"
      ],
      "a": [
         "incurs minimum cost"
      ]
   },
   {
      "q": "Cost factors of process termination include:",
      "c": [
         "Number of resources the deadlock process is not holding",
         "CPU utilization at the time of deadlock",
         "Amount of time a deadlocked process has thus far consumed during its execution",
         "All of the mentioned"
      ],
      "a": [
         "Amount of time a deadlocked process has thus far consumed during its execution"
      ]
   },
   {
      "q": "If we preempt a resource from a process, the process cannot continue with its normal execution and it must be:",
      "c": [
         "aborted",
         "rolled back",
         "terminated",
         "queued"
      ],
      "a": [
         "rolled back"
      ]
   },
   {
      "q": "To --?-- to a safe state, the system needs to keep more information about the states of processes.",
      "c": [
         "abort the process",
         "roll back the process",
         "queue the process",
         "none of the mentioned"
      ],
      "a": [
         "roll back the process"
      ]
   },
   {
      "q": "If the resources are always preempted from the same process, --?-- can occur.",
      "c": [
         "deadlock",
         "system crash",
         "aging",
         "starvation"
      ],
      "a": [
         "starvation"
      ]
   },
   {
      "q": "The solution to starvation is:",
      "c": [
         "the number of rollbacks must be included in the cost factor",
         "the number of resources must be included in resource preemption",
         "resource preemption be done instead",
         "all of the mentioned"
      ],
      "a": [
         "the number of rollbacks must be included in the cost factor"
      ]
   },
   {
      "q": "Address Binding is:",
      "c": [
         "going to an address in memory",
         "locating an address with the help of another address",
         "binding two addresses together to form a new address in a different memory space",
         "a mapping from one address space to another"
      ],
      "a": [
         "a mapping from one address space to another"
      ]
   },
   {
      "q": "Binding of instructions and data to memory addresses can be done at:",
      "c": [
         "Compile time",
         "Load time",
         "Execution time",
         "All of the mentioned"
      ],
      "a": [
         "All of the mentioned"
      ]
   },
   {
      "q": "If the process can be moved during its execution from one memory segment to another, then binding must be:",
      "c": [
         "delayed until run time",
         "preponed to compile time",
         "preponed to load time",
         "none of the mentioned"
      ],
      "a": [
         "delayed until run time"
      ]
   },
   {
      "q": "Dynamic loading is:",
      "c": [
         "loading multiple routines dynamically",
         "loading a routine only when it is called",
         "loading multiple routines randomly",
         "none of the mentioned"
      ],
      "a": [
         "loading a routine only when it is called"
      ]
   },
   {
      "q": "The advantage of dynamic loading is that:",
      "c": [
         "A used routine is used multiple times",
         "An unused routine is never loaded",
         "CPU utilization increases",
         "All of the mentioned"
      ],
      "a": [
         "An unused routine is never loaded"
      ]
   },
   {
      "q": "The idea of overlays is to:",
      "c": [
         "data that are needed at any given time",
         "enable a process to be larger than the amount of memory allocated to it",
         "keep in memory only those instructions",
         "all of the mentioned"
      ],
      "a": [
         "all of the mentioned"
      ]
   },
   {
      "q": "The --?-- swaps processes in and out of the memory.",
      "c": [
         "Memory manager",
         "CPU",
         "CPU manager",
         "User"
      ],
      "a": [
         "Memory manager"
      ]
   },
   {
      "q": "If binding is done at assembly or load time, then the process --?-- be moved to different locations after being swapped out and in again.",
      "c": [
         "can",
         "must",
         "can never",
         "may"
      ],
      "a": [
         "can never"
      ]
   },
   {
      "q": "In a system that does not support swapping:",
      "c": [
         "the compiler normally binds symbolic addresses (variables) to relocatable addresses",
         "the compiler normally binds symbolic addresses to physical addresses",
         "the loader binds relocatable addresses to physical addresses",
         "binding of symbolic addresses to physical addresses normally takes place during execution"
      ],
      "a": [
         "the compiler normally binds symbolic addresses (variables) to relocatable addresses"
      ]
   },
   {
      "q": "Which of the following is TRUE?",
      "c": [
         "Overlays are used to increase the size of physical memory",
         "Overlays are used to increase the logical address space",
         "When overlays are used, the size of a process is not limited to the size of the physical memory",
         "Overlays are used whenever the physical address space is smaller than the logical address space"
      ],
      "a": [
         "When overlays are used, the size of a process is not limited to the size of the physical memory"
      ]
   },
   {
      "q": "The run time mapping from virtual to physical addresses is done by a hardware device called the:",
      "c": [
         "Virtual to physical mapper",
         "Memory management unit",
         "Memory mapping unit",
         "None of the mentioned"
      ],
      "a": [
         "Memory management unit"
      ]
   },
   {
      "q": "The base register is also known as the:",
      "c": [
         "basic register",
         "regular register",
         "relocation register",
         "delocation register"
      ],
      "a": [
         "relocation register"
      ]
   },
   {
      "q": "The size of a process is limited to the size of:",
      "c": [
         "physical memory",
         "external storage",
         "secondary storage",
         "none of the mentioned"
      ],
      "a": [
         "physical memory"
      ]
   },
   {
      "q": "If execution time binding is being used, then a process --?-- be swapped to a different memory space.",
      "c": [
         "has to be",
         "can never",
         "must",
         "may"
      ],
      "a": [
         "may"
      ]
   },
   {
      "q": "Swapping requires a:",
      "c": [
         "motherboard",
         "keyboard",
         "monitor",
         "backing store"
      ],
      "a": [
         "backing store"
      ]
   },
   {
      "q": "The backing store is generally a:",
      "c": [
         "fast disk",
         "disk large enough to accommodate copies of all memory images for all users",
         "disk to provide direct access to the memory images",
         "all of the mentioned"
      ],
      "a": [
         "all of the mentioned"
      ]
   },
   {
      "q": "The --?-- consists of all processes whose memory images are in the backing store or in memory and are ready to run.",
      "c": [
         "wait queue",
         "ready queue",
         "cpu",
         "secondary storage"
      ],
      "a": [
         "ready queue"
      ]
   },
   {
      "q": "The --?-- time in a swap out of a running process and swap in of a new process into the memory is very high.",
      "c": [
         "context \u2013 switch",
         "waiting",
         "execution",
         "all of the mentioned"
      ],
      "a": [
         "context \u2013 switch"
      ]
   },
   {
      "q": "The major part of swap time is --?-- time.",
      "c": [
         "waiting",
         "transfer",
         "execution",
         "none of the mentioned"
      ],
      "a": [
         "transfer"
      ]
   },
   {
      "q": "Swapping --?-- be done when a process has pending I/O, or has to execute I/O operations only into operating system buffers.",
      "c": [
         "must",
         "can",
         "must never",
         "maybe"
      ],
      "a": [
         "must never"
      ]
   },
   {
      "q": "Swap space is allocated:",
      "c": [
         "as a chunk of disk",
         "separate from a file system",
         "into a file system",
         "all of the mentioned"
      ],
      "a": [
         "as a chunk of disk"
      ]
   },
   {
      "q": "CPU fetches the instruction from memory according to the value of:",
      "c": [
         "program counter",
         "status register",
         "instruction register",
         "program status word"
      ],
      "a": [
         "program counter"
      ]
   },
   {
      "q": "A memory buffer used to accommodate a speed differential is called:",
      "c": [
         "stack pointer",
         "cache",
         "accumulator",
         "disk buffer"
      ],
      "a": [
         "cache"
      ]
   },
   {
      "q": "Which one of the following is the address generated by CPU?",
      "c": [
         "physical address",
         "absolute address",
         "logical address",
         "none of the mentioned"
      ],
      "a": [
         "logical address"
      ]
   },
   {
      "q": "Run time mapping from virtual to physical address is done by:",
      "c": [
         "Memory management unit",
         "CPU",
         "PCI",
         "None of the mentioned"
      ],
      "a": [
         "Memory management unit"
      ]
   },
   {
      "q": "Memory management technique in which system stores and retrieves data from secondary storage for use in main memory is called:",
      "c": [
         "fragmentation",
         "paging",
         "mapping",
         "none of the mentioned"
      ],
      "a": [
         "paging"
      ]
   },
   {
      "q": "The address of a page table in memory is pointed by:",
      "c": [
         "stack pointer",
         "page table base register",
         "page register",
         "program counter"
      ],
      "a": [
         "page table base register"
      ]
   },
   {
      "q": "The page table contains:",
      "c": [
         "base address of each page in physical memory",
         "page offset",
         "page size",
         "none of the mentioned"
      ],
      "a": [
         "base address of each page in physical memory"
      ]
   },
   {
      "q": "What is compaction?",
      "c": [
         "a technique for overcoming internal fragmentation",
         "a paging technique",
         "a technique for overcoming external fragmentation",
         "a technique for overcoming fatal error"
      ],
      "a": [
         "a technique for overcoming external fragmentation"
      ]
   },
   {
      "q": "Operating System maintains the page table for:",
      "c": [
         "each process",
         "each thread",
         "each instruction",
         "each address"
      ],
      "a": [
         "each process"
      ]
   },
   {
      "q": "The main memory accommodates:",
      "c": [
         "operating system",
         "cpu",
         "user processes",
         "all of the mentioned"
      ],
      "a": [
         "operating system"
      ]
   },
   {
      "q": "In contiguous memory allocation:",
      "c": [
         "each process is contained in a single contiguous section of memory",
         "all processes are contained in a single contiguous section of memory",
         "the memory space is contiguous",
         "none of the mentioned"
      ],
      "a": [
         "each process is contained in a single contiguous section of memory"
      ]
   },
   {
      "q": "The relocation register helps in:",
      "c": [
         "providing more address space to processes",
         "a different address space to processes",
         "protecting the address spaces of processes",
         "none of the mentioned"
      ],
      "a": [
         "protecting the address spaces of processes"
      ]
   },
   {
      "q": "With relocation and limit registers, each logical address must be --?-- the limit register.",
      "c": [
         "less than",
         "equal to",
         "greater than",
         "none of the mentioned"
      ],
      "a": [
         "less than"
      ]
   },
   {
      "q": "The operating system and the other processes are protected from being modified by an already running process because:",
      "c": [
         "they are in different memory spaces",
         "they are in different logical addresses",
         "they have a protection algorithm",
         "every address generated by the CPU is being checked against the relocation and limit registers"
      ],
      "a": [
         "every address generated by the CPU is being checked against the relocation and limit registers"
      ]
   },
   {
      "q": "Transient operating system code is code that:",
      "c": [
         "is not easily accessible",
         "comes and goes as needed",
         "stays in the memory always",
         "never enters the memory space"
      ],
      "a": [
         "comes and goes as needed"
      ]
   },
   {
      "q": "Using transient code, --?-- the size of the operating system during program execution.",
      "c": [
         "increases",
         "decreases",
         "changes",
         "maintains"
      ],
      "a": [
         "changes"
      ]
   },
   {
      "q": "When memory is divided into several fixed sized partitions, each partition may contain:",
      "c": [
         "exactly one process",
         "at least one process",
         "multiple processes at once",
         "none of the mentioned"
      ],
      "a": [
         "exactly one process"
      ]
   },
   {
      "q": "In fixed size partition, the degree of multiprogramming is bounded by:",
      "c": [
         "the number of partitions",
         "the CPU utilization",
         "the memory size",
         "all of the mentioned"
      ],
      "a": [
         "the number of partitions"
      ]
   },
   {
      "q": "In internal fragmentation, memory is internal to a partition and:",
      "c": [
         "is being used",
         "is not being used",
         "is always used",
         "none of the mentioned"
      ],
      "a": [
         "is not being used"
      ]
   },
   {
      "q": "A solution to the problem of external fragmentation is:",
      "c": [
         "compaction",
         "larger memory space",
         "smaller memory space",
         "none of the mentioned"
      ],
      "a": [
         "compaction"
      ]
   },
   {
      "q": "Another solution to the problem of external fragmentation problem is to:",
      "c": [
         "permit the logical address space of a process to be noncontiguous",
         "permit smaller processes to be allocated memory at last",
         "permit larger processes to be allocated memory at last",
         "all of the mentioned"
      ],
      "a": [
         "permit the logical address space of a process to be noncontiguous"
      ]
   },
   {
      "q": "If relocation is static and is done at assembly or load time, compaction:",
      "c": [
         "cannot be done",
         "must be done",
         "must not be done",
         "can be done"
      ],
      "a": [
         "cannot be done"
      ]
   },
   {
      "q": "The disadvantage of moving all process to one end of memory and all holes to the other direction, producing one large hole of available memory is:",
      "c": [
         "the cost incurred",
         "the memory used",
         "the CPU used",
         "all of the mentioned"
      ],
      "a": [
         "the cost incurred"
      ]
   },
   {
      "q": "--?-- is generally faster than --?-- and --?--",
      "c": [
         "first fit, best fit, worst fit",
         "best fit, first fit, worst fit",
         "worst fit, best fit, first fit",
         "none of the mentioned"
      ],
      "a": [
         "first fit, best fit, worst fit"
      ]
   },
   {
      "q": "External fragmentation exists when:",
      "c": [
         "enough total memory exists to satisfy a request but it is not contiguous",
         "the total memory is insufficient to satisfy a request",
         "a request cannot be satisfied even when the total memory is free",
         "none of the mentioned"
      ],
      "a": [
         "enough total memory exists to satisfy a request but it is not contiguous"
      ]
   },
   {
      "q": "External fragmentation will not occur when:",
      "c": [
         "first fit is used",
         "best fit is used",
         "worst fit is used",
         "no matter which algorithm is used, it will always occur"
      ],
      "a": [
         "no matter which algorithm is used, it will always occur"
      ]
   },
   {
      "q": "Sometimes the overhead of keeping track of a hole might be:",
      "c": [
         "larger than the memory",
         "larger than the hole itself",
         "very small",
         "all of the mentioned"
      ],
      "a": [
         "larger than the hole itself"
      ]
   },
   {
      "q": "When the memory allocated to a process is slightly larger than the process, then:",
      "c": [
         "internal fragmentation occurs",
         "external fragmentation occurs",
         "both internal and external fragmentation occurs",
         "neither internal nor external fragmentation occurs"
      ],
      "a": [
         "internal fragmentation occurs"
      ]
   },
   {
      "q": "Physical memory is broken into fixed-sized blocks called:",
      "c": [
         "frames",
         "pages",
         "backing store",
         "none of the mentioned"
      ],
      "a": [
         "frames"
      ]
   },
   {
      "q": "Logical memory is broken into blocks of the same size called:",
      "c": [
         "frames",
         "pages",
         "backing store",
         "none of the mentioned"
      ],
      "a": [
         "pages"
      ]
   },
   {
      "q": "Every address generated by the CPU is divided into two parts:",
      "c": [
         "frame bit & page number",
         "page number & page offset",
         "page offset & frame bit",
         "frame offset & page offset"
      ],
      "a": [
         "page number & page offset"
      ]
   },
   {
      "q": "The --?-- is used as an index into the page table.",
      "c": [
         "frame bit",
         "page number",
         "page offset",
         "frame offset"
      ],
      "a": [
         "page number"
      ]
   },
   {
      "q": "The --?-- table contains the base address of each page in physical memory.",
      "c": [
         "process",
         "memory",
         "page",
         "frame"
      ],
      "a": [
         "page"
      ]
   },
   {
      "q": "With paging there is no --?-- fragmentation.",
      "c": [
         "internal",
         "external",
         "either type of",
         "none of the mentioned"
      ],
      "a": [
         "external"
      ]
   },
   {
      "q": "Paging increases the --?-- time.",
      "c": [
         "waiting",
         "execution",
         "context \u2013 switch",
         "all of the mentioned"
      ],
      "a": [
         "context \u2013 switch"
      ]
   },
   {
      "q": "Smaller page tables are implemented as a set of:",
      "c": [
         "queues",
         "stacks",
         "counters",
         "registers"
      ],
      "a": [
         "registers"
      ]
   },
   {
      "q": "The page table registers should be built with:",
      "c": [
         "very low speed logic",
         "very high speed logic",
         "a large memory space",
         "none of the mentioned"
      ],
      "a": [
         "very high speed logic"
      ]
   },
   {
      "q": "For larger page tables, they are kept in main memory and a --?-- points to the page table.",
      "c": [
         "page table base register",
         "page table base pointer",
         "page table register pointer",
         "page table base"
      ],
      "a": [
         "page table base register"
      ]
   },
   {
      "q": "For every process there is a:",
      "c": [
         "page table",
         "copy of page table",
         "pointer to page table",
         "all of the mentioned"
      ],
      "a": [
         "page table"
      ]
   },
   {
      "q": "Time taken in memory access through PTBR is:",
      "c": [
         "extended by a factor of 3",
         "extended by a factor of 2",
         "slowed by a factor of 3",
         "slowed by a factor of 2"
      ],
      "a": [
         "slowed by a factor of 2"
      ]
   },
   {
      "q": "Each entry in a Translation lookaside buffer (TLB) consists of:",
      "c": [
         "key",
         "value",
         "bit value",
         "constant"
      ],
      "a": [
         "key"
      ]
   },
   {
      "q": "If a page number is not found in the TLB, then it is known as a:",
      "c": [
         "TLB miss",
         "Buffer miss",
         "TLB hit",
         "All of the mentioned"
      ],
      "a": [
         "TLB miss"
      ]
   },
   {
      "q": "An --?-- uniquely identifies processes and is used to provide address space protection for that process.",
      "c": [
         "address space locator",
         "address space identifier",
         "address process identifier",
         "None of the mentioned"
      ],
      "a": [
         "address space identifier"
      ]
   },
   {
      "q": "The percentage of times a page number is found in the TLB is known as:",
      "c": [
         "miss ratio",
         "hit ratio",
         "miss percent",
         "None of the mentioned"
      ],
      "a": [
         "hit ratio"
      ]
   },
   {
      "q": "Memory protection in a paged environment is accomplished by:",
      "c": [
         "protection algorithm with each page",
         "restricted access rights to users",
         "restriction on page visibility",
         "protection bit with each page"
      ],
      "a": [
         "protection bit with each page"
      ]
   },
   {
      "q": "When the valid \u2013 invalid bit is set to valid, it means that the associated page:",
      "c": [
         "is in the TLB",
         "has data in it",
         "is in the process\u2019s logical address space",
         "is the system\u2019s physical address space"
      ],
      "a": [
         "is in the process\u2019s logical address space"
      ]
   },
   {
      "q": "Illegal addresses are trapped using the --?-- bit.",
      "c": [
         "error",
         "protection",
         "valid \u2013 invalid",
         "access"
      ],
      "a": [
         "valid \u2013 invalid"
      ]
   },
   {
      "q": "When there is a large logical address space, the best way of paging would be:",
      "c": [
         "not to page",
         "a two level paging algorithm",
         "the page table itself",
         "all of the mentioned"
      ],
      "a": [
         "a two level paging algorithm"
      ]
   },
   {
      "q": "To obtain better memory utilization, dynamic loading is used. With dynamic loading, a routine is not loaded until it is called. For implementing dynamic loading:",
      "c": [
         "special support from hardware is required",
         "special support from operating system is essential",
         "special support from both hardware and operating system is essential",
         "user programs can implement dynamic loading without any special support from hardware or operating system"
      ],
      "a": [
         "user programs can implement dynamic loading without any special support from hardware or operating system"
      ]
   },
   {
      "q": "In paged memory systems, if the page size is increased, then the internal fragmentation generally:",
      "c": [
         "becomes less",
         "becomes more",
         "remains constant",
         "none of the mentioned"
      ],
      "a": [
         "becomes more"
      ]
   },
   {
      "q": "In segmentation, each address is specified by:",
      "c": [
         "a segment number & offset",
         "an offset & value",
         "a value & segment number",
         "a key & value"
      ],
      "a": [
         "a segment number & offset"
      ]
   },
   {
      "q": "In paging the user provides only --?-- which is partitioned by the hardware into --?-- and --?--",
      "c": [
         "one address, page number, offset",
         "one offset, page number, address",
         "page number, offset, address",
         "none of the mentioned"
      ],
      "a": [
         "one address, page number, offset"
      ]
   },
   {
      "q": "Each entry in a segment table has a:",
      "c": [
         "segment base",
         "segment peak",
         "segment value",
         "none of the mentioned"
      ],
      "a": [
         "segment base"
      ]
   },
   {
      "q": "The segment base contains the:",
      "c": [
         "starting logical address of the process",
         "starting physical address of the segment in memory",
         "segment length",
         "none of the mentioned"
      ],
      "a": [
         "starting physical address of the segment in memory"
      ]
   },
   {
      "q": "The segment limit contains the:",
      "c": [
         "starting logical address of the process",
         "starting physical address of the segment in memory",
         "segment length",
         "none of the mentioned"
      ],
      "a": [
         "segment length"
      ]
   },
   {
      "q": "The offset \u2018d\u2019 of the logical address must be:",
      "c": [
         "greater than segment limit",
         "between 0 and segment limit",
         "between 0 and the segment number",
         "greater than the segment number"
      ],
      "a": [
         "between 0 and segment limit"
      ]
   },
   {
      "q": "If the offset is legal:",
      "c": [
         "it is used as a physical memory address itself",
         "it is subtracted from the segment base to produce the physical memory address",
         "it is added to the segment base to produce the physical memory address",
         "none of the mentioned"
      ],
      "a": [
         "it is used as a physical memory address itself"
      ]
   },
   {
      "q": "When the entries in the segment tables of two different processes point to the same physical location:",
      "c": [
         "the segments are invalid",
         "the processes get blocked",
         "segments are shared",
         "all of the mentioned"
      ],
      "a": [
         "segments are shared"
      ]
   },
   {
      "q": "The protection bit is 0/1 based on:",
      "c": [
         "write only",
         "read only",
         "read \u2013 write",
         "none of the mentioned"
      ],
      "a": [
         "read \u2013 write"
      ]
   },
   {
      "q": "A multilevel page table is preferred in comparison to a single level page table for translating virtual address to physical address because:",
      "c": [
         "it reduces the memory access time to read or write a memory location",
         "it helps to reduce the size of page table needed to implement the virtual address space of a process",
         "it is required by the translation lookaside buffer",
         "it helps to reduce the number of page faults in page replacement algorithms"
      ],
      "a": [
         "it helps to reduce the size of page table needed to implement the virtual address space of a process"
      ]
   },
   {
      "q": "If one or more devices use a common set of wires to communicate with the computer system, the connection is called:",
      "c": [
         "CPU",
         "Monitor",
         "Wirefull",
         "Bus"
      ],
      "a": [
         "Bus"
      ]
   },
   {
      "q": "A --?-- is a set of wires and a rigidly defined protocol that specifies a set of messages that can be sent on the wires.",
      "c": [
         "port",
         "node",
         "bus",
         "none of the mentioned"
      ],
      "a": [
         "bus"
      ]
   },
   {
      "q": "When device A has a cable that plugs into device B, and device B has a cable that plugs into device C and device C plugs into a port on the computer, this arrangement is called a _________",
      "c": [
         "port",
         "daisy chain",
         "bus",
         "cable"
      ],
      "a": [
         "daisy chain"
      ]
   },
   {
      "q": "The --?-- present a uniform device-access interface to the I/O subsystem, much as system calls provide a standard interface between the application and the operating system.",
      "c": [
         "Devices",
         "Buses",
         "Device drivers",
         "I/O systems"
      ],
      "a": [
         "Device drivers"
      ]
   },
   {
      "q": "A --?-- is a collection of electronics that can operate a port, a bus, or a device.",
      "c": [
         "controller",
         "driver",
         "host",
         "bus"
      ],
      "a": [
         "controller"
      ]
   },
   {
      "q": "An I/O port typically consists of four registers status, control, --?-- and --?-- registers.",
      "c": [
         "system in, system out",
         "data in, data out",
         "flow in, flow out",
         "input, output"
      ],
      "a": [
         "data in, data out"
      ]
   },
   {
      "q": "The hardware mechanism that allows a device to notify the CPU is called:",
      "c": [
         "polling",
         "interrupt",
         "driver",
         "controlling"
      ],
      "a": [
         "interrupt"
      ]
   },
   {
      "q": "The CPU hardware has a wire called --?-- that the CPU senses after executing every instruction.",
      "c": [
         "interrupt request line",
         "interrupt bus",
         "interrupt receive line",
         "interrupt sense line"
      ],
      "a": [
         "interrupt request line"
      ]
   },
   {
      "q": "The --?-- determines the cause of the interrupt, performs the necessary processing and executes a return from the interrupt instruction to return the CPU to the execution state prior to the interrupt.",
      "c": [
         "interrupt request line",
         "device driver",
         "interrupt handler",
         "all of the mentioned"
      ],
      "a": [
         "interrupt handler"
      ]
   },
   {
      "q": "In general the two interrupt request lines are:",
      "c": [
         "maskable & non maskable interrupts",
         "blocked & non maskable interrupts",
         "maskable & blocked interrupts",
         "none of the mentioned"
      ],
      "a": [
         "maskable & non maskable interrupts"
      ]
   },
   {
      "q": "The --?-- are reserved for events such as unrecoverable memory errors.",
      "c": [
         "non maskable interrupts",
         "blocked interrupts",
         "maskable interrupts",
         "none of the mentioned"
      ],
      "a": [
         "non maskable interrupts"
      ]
   },
   {
      "q": "The --?-- can be turned off by the CPU before the execution of critical instruction sequences that must not be interrupted.",
      "c": [
         "nonmaskable interrupt",
         "blocked interrupt",
         "maskable interrupt",
         "none of the mentioned"
      ],
      "a": [
         "maskable interrupt"
      ]
   },
   {
      "q": "The --?-- can be turned off by the CPU before the execution of critical instruction sequences that must not be interrupted.",
      "c": [
         "nonmaskable interrupt",
         "blocked interrupt",
         "maskable interrupt",
         "none of the mentioned"
      ],
      "a": [
         "maskable interrupt"
      ]
   },
   {
      "q": "The --?-- is used by device controllers to request service.",
      "c": [
         "nonmaskable interrupt",
         "blocked interrupt",
         "maskable interrupt",
         "none of the mentioned"
      ],
      "a": [
         "maskable interrupt"
      ]
   },
   {
      "q": "The interrupt vector contains:",
      "c": [
         "the interrupts",
         "the memory addresses of specialized interrupt handlers",
         "the identifiers of interrupts",
         "the device addresses"
      ],
      "a": [
         "the memory addresses of specialized interrupt handlers"
      ]
   },
   {
      "q": "Division by zero, accessing a protected or non existent memory address, or attempting to execute a privileged instruction from user mode are all categorized as:",
      "c": [
         "errors",
         "exceptions",
         "interrupt handlers",
         "all of the mentioned"
      ],
      "a": [
         "exceptions"
      ]
   },
   {
      "q": "For large data transfers, --?-- is used.",
      "c": [
         "dma",
         "programmed I/O",
         "controller register",
         "none of the mentioned"
      ],
      "a": [
         "dma"
      ]
   },
   {
      "q": "A character stream device transfers:",
      "c": [
         "bytes one by one",
         "block of bytes as a unit",
         "with unpredictable response times",
         "none of the mentioned"
      ],
      "a": [
         "bytes one by one"
      ]
   },
   {
      "q": "A block device transfers:",
      "c": [
         "bytes one by one",
         "block of bytes as a unit",
         "with unpredictable response times",
         "none of the mentioned"
      ],
      "a": [
         "block of bytes as a unit"
      ]
   },
   {
      "q": "A dedicated device is:",
      "c": [
         "opposite to a sharable device",
         "same as a sharable device",
         "can be used concurrently by several processes",
         "none of the mentioned"
      ],
      "a": [
         "opposite to a sharable device"
      ]
   },
   {
      "q": "In polling:",
      "c": [
         "busy \u2013 wait cycles wait for I/O from device",
         "interrupt handler receives interrupts",
         "interrupt-request line is triggered by I/O device",
         "all of the mentioned"
      ],
      "a": [
         "busy \u2013 wait cycles wait for I/O from device"
      ]
   },
   {
      "q": "A non blocking system call:",
      "c": [
         "halts the execution of the application for an extended time",
         "does not halt the execution of the application",
         "does not block the interrupts",
         "none of the mentioned"
      ],
      "a": [
         "does not halt the execution of the application"
      ]
   },
   {
      "q": "An asynchronous call:",
      "c": [
         "returns immediately, without waiting for the I/O to complete",
         "does not return immediately and waits for the I/O to complete",
         "consumes a lot of time",
         "is too slow"
      ],
      "a": [
         "returns immediately, without waiting for the I/O to complete"
      ]
   },
   {
      "q": "Buffering is done to:",
      "c": [
         "cope with device speed mismatch",
         "cope with device transfer size mismatch",
         "maintain copy semantics",
         "all of the mentioned"
      ],
      "a": [
         "all of the mentioned"
      ]
   },
   {
      "q": "Caching is --?-- spooling.",
      "c": [
         "same as",
         "not the same as",
         "all of the mentioned",
         "none of the mentioned"
      ],
      "a": [
         "not the same as"
      ]
   },
   {
      "q": "Caching:",
      "c": [
         "holds a copy of the data",
         "is fast memory",
         "holds the only copy of the data",
         "holds output for a device"
      ],
      "a": [
         "holds a copy of the data"
      ]
   },
   {
      "q": "Spooling:",
      "c": [
         "holds a copy of the data",
         "is fast memory",
         "holds the only copy of the data",
         "holds output for a device"
      ],
      "a": [
         "holds the only copy of the data"
      ]
   },
   {
      "q": "The --?-- keeps state information about the use of I/O components.",
      "c": [
         "CPU",
         "OS",
         "kernel",
         "shell"
      ],
      "a": [
         "kernel"
      ]
   },
   {
      "q": "The kernel data structures include:",
      "c": [
         "process table",
         "open file table",
         "close file table",
         "all of the mentioned"
      ],
      "a": [
         "open file table"
      ]
   },
   {
      "q": "Windows NT uses a --?-- implementation for I/O",
      "c": [
         "message \u2013 passing",
         "draft \u2013 passing",
         "secondary memory",
         "cache"
      ],
      "a": [
         "message \u2013 passing"
      ]
   },
   {
      "q": "A --?-- is a full duplex connection between a device driver and a user level process.",
      "c": [
         "Bus",
         "I/O operation",
         "Stream",
         "Flow"
      ],
      "a": [
         "Stream"
      ]
   },
   {
      "q": "I/O is a --?-- in system performance.",
      "c": [
         "major factor",
         "minor factor",
         "does not matter",
         "none of the mentioned"
      ],
      "a": [
         "major factor"
      ]
   },
   {
      "q": "If the number of cycles spent busy \u2013 waiting is not excessive, then:",
      "c": [
         "interrupt driven I/O is more efficient than programmed I/O",
         "programmed I/O is more efficient than interrupt driven I/O",
         "both programmed and interrupt driven I/O are equally efficient",
         "none of the mentioned"
      ],
      "a": [
         "programmed I/O is more efficient than interrupt driven I/O"
      ]
   },
   {
      "q": "In real time operating system:",
      "c": [
         "all processes have the same priority",
         "a task must be serviced by its deadline period",
         "process scheduling can be done only once",
         "kernel is not required"
      ],
      "a": [
         "a task must be serviced by its deadline period"
      ]
   },
   {
      "q": "For real time operating systems, interrupt latency should be:",
      "c": [
         "minimal",
         "maximum",
         "zero",
         "dependent on the scheduling"
      ],
      "a": [
         "minimal"
      ]
   },
   {
      "q": "The problem of priority inversion can be solved by:",
      "c": [
         "priority inheritance protocol",
         "priority inversion protocol",
         "both priority inheritance and inversion protocol",
         "none of the mentioned"
      ],
      "a": [
         "priority inheritance protocol"
      ]
   },
   {
      "q": "Time duration required for scheduling dispatcher to stop one process and start another is known as:",
      "c": [
         "process latency",
         "dispatch latency",
         "execution latency",
         "interrupt latency"
      ],
      "a": [
         "dispatch latency"
      ]
   },
   {
      "q": "Time required to synchronous switch from the context of one thread to the context of another thread is called:",
      "c": [
         "threads fly-back time",
         "jitter",
         "context switch time",
         "none of the mentioned"
      ],
      "a": [
         "context switch time"
      ]
   },
   {
      "q": "The disadvantage of real addressing mode is:",
      "c": [
         "there is a lot of cost involved",
         "time consumption overhead",
         "absence of memory protection between processes",
         "restricted access to memory locations by processes"
      ],
      "a": [
         "absence of memory protection between processes"
      ]
   },
   {
      "q": "Preemptive, priority based scheduling guarantees:",
      "c": [
         "hard real time functionality",
         "soft real time functionality",
         "protection of memory",
         "none of the mentioned"
      ],
      "a": [
         "soft real time functionality"
      ]
   },
   {
      "q": "Real time systems must have:",
      "c": [
         "preemptive kernels",
         "non preemptive kernels",
         "preemptive kernels or non preemptive kernels",
         "neither preemptive nor non preemptive kernels"
      ],
      "a": [
         "preemptive kernels"
      ]
   },
   {
      "q": "Event latency is:",
      "c": [
         "the amount of time an event takes to occur from when the system started",
         "the amount of time from the event occurrence till the system stops",
         "the amount of time from event occurrence till the event crashes",
         "the amount of time that elapses from when an event occurs to when it is serviced."
      ],
      "a": [
         "the amount of time that elapses from when an event occurs to when it is serviced."
      ]
   },
   {
      "q": "Interrupt latency refers to the period of time:",
      "c": [
         "from the occurrence of an event to the arrival of an interrupt",
         "from the occurrence of an event to the servicing of an interrupt",
         "from arrival of an interrupt to the start of the interrupt service routine",
         "none of the mentioned"
      ],
      "a": [
         "from arrival of an interrupt to the start of the interrupt service routine"
      ]
   },
   {
      "q": "Real time systems need to --?-- the interrupt latency.",
      "c": [
         "minimize",
         "maximize",
         "not bother about",
         "none of the mentioned"
      ],
      "a": [
         "minimize"
      ]
   },
   {
      "q": "The amount of time required for the scheduling dispatcher to stop one process and start another is known as:",
      "c": [
         "event latency",
         "interrupt latency",
         "dispatch latency",
         "context switch"
      ],
      "a": [
         "dispatch latency"
      ]
   },
   {
      "q": "The most effective technique to keep dispatch latency low is to:",
      "c": [
         "provide non preemptive kernels",
         "provide preemptive kernels",
         "make it user programmed",
         "run less number of processes at a time"
      ],
      "a": [
         "provide preemptive kernels"
      ]
   },
   {
      "q": "In a safety critical system, incorrect operation:",
      "c": [
         "does not affect much",
         "causes minor problems",
         "causes major and serious problems",
         "none of the mentioned"
      ],
      "a": [
         "causes major and serious problems"
      ]
   },
   {
      "q": "In a --?-- real time system, it is guaranteed that critical real time tasks will be completed within their deadlines.",
      "c": [
         "soft",
         "hard",
         "critical",
         "none of the mentioned"
      ],
      "a": [
         "hard"
      ]
   },
   {
      "q": "Some of the properties of real time systems include:",
      "c": [
         "single purpose",
         "inexpensively mass produced",
         "small size",
         "all of the mentioned"
      ],
      "a": [
         "all of the mentioned"
      ]
   },
   {
      "q": "The amount of memory in a real time system is generally:",
      "c": [
         "less compared to PCs",
         "high compared to PCs",
         "same as in PCs",
         "they do not have any memory"
      ],
      "a": [
         "less compared to PCs"
      ]
   },
   {
      "q": "The priority of a real time task:",
      "c": [
         "must degrade over time",
         "must not degrade over time",
         "may degrade over time",
         "none of the mentioned"
      ],
      "a": [
         "must not degrade over time"
      ]
   },
   {
      "q": "Memory management units:",
      "c": [
         "increase the cost of the system",
         "increase the power consumption of the system",
         "increase the time required to complete an operation",
         "all of the mentioned"
      ],
      "a": [
         "all of the mentioned"
      ]
   },
   {
      "q": "The technique in which the CPU generates physical addresses directly is known as:",
      "c": [
         "relocation register method",
         "real addressing",
         "virtual addressing",
         "none of the mentioned"
      ],
      "a": [
         "real addressing"
      ]
   },
   {
      "q": "The scheduler admits a process using:",
      "c": [
         "two phase locking protocol",
         "admission control algorithm",
         "busy wait polling",
         "none of the mentioned"
      ],
      "a": [
         "busy wait polling"
      ]
   },
   {
      "q": "An admission control scheme assigns a --?-- to each type of resource.",
      "c": [
         "processor",
         "memory location",
         "resource manager",
         "all of the mentioned"
      ],
      "a": [
         "resource manager"
      ]
   },
   {
      "q": "The priority of a process will --?-- if the scheduler assigns it a static priority.",
      "c": [
         "change",
         "remain unchanged",
         "depends on the operating system",
         "none of the mentioned"
      ],
      "a": [
         "remain unchanged"
      ]
   },
   {
      "q": "As disks have relatively low transfer rates and relatively high latency rates, disk schedulers must reduce latency times to:",
      "c": [
         "ensure high bandwidth",
         "ensure low bandwidth",
         "make sure data is transferred",
         "reduce data transfer speeds"
      ],
      "a": [
         "ensure high bandwidth"
      ]
   },
   {
      "q": "Multimedia systems require --?-- scheduling to ensure critical tasks will be serviced within timing deadlines.",
      "c": [
         "soft real time",
         "hard real time",
         "normal",
         "none of the mentioned"
      ],
      "a": [
         "hard real time"
      ]
   },
   {
      "q": "What are common security threats?",
      "c": [
         "File Shredding",
         "File sharing and permission",
         "File integrity",
         "File shredding and integrity"
      ],
      "a": [
         "File sharing and permission"
      ]
   },
   {
      "q": "From the following, which is not a common file permission?",
      "c": [
         "Write",
         "Execute",
         "Stop",
         "Read"
      ],
      "a": [
         "Stop"
      ]
   },
   {
      "q": "Which of the following is a good practice?",
      "c": [
         "Give full permission for remote transferring",
         "Grant read only permission",
         "Grant limited permission to specified account",
         "Give both read and write permission but not execute"
      ],
      "a": [
         "Grant limited permission to specified account"
      ]
   },
   {
      "q": "What is not a good practice for user administration?",
      "c": [
         "Isolating a system after a compromise",
         "Perform random auditing procedures",
         "Granting privileges on a per host basis",
         "Using telnet and FTP for remote access"
      ],
      "a": [
         "Using telnet and FTP for remote access"
      ]
   },
   {
      "q": "Which of the following is least secure method of authentication?",
      "c": [
         "Key card",
         "fingerprint",
         "retina pattern",
         "Password"
      ],
      "a": [
         "Password"
      ]
   },
   {
      "q": "What is characteristics of Authorization?",
      "c": [
         "RADIUS and RSA",
         "3 way handshaking with syn and fin",
         "Multilayered protection for securing resources",
         "Deals with privileges and rights"
      ],
      "a": [
         "Deals with privileges and rights"
      ]
   },
   {
      "q": "What is breach of integrity?",
      "c": [
         "This type of violation involves unauthorized reading of data",
         "This violation involves unauthorized modification of data",
         "This violation involves unauthorized destruction of data",
         "This violation involves unauthorized use of resources"
      ],
      "a": [
         "This violation involves unauthorized modification of data"
      ]
   },
   {
      "q": "What is breach of confidentiality?",
      "c": [
         "This type of violation involves unauthorized reading of data",
         "This violation involves unauthorized modification of data",
         "This violation involves unauthorized destruction of data",
         "This violation involves unauthorized use of resources"
      ],
      "a": [
         "This type of violation involves unauthorized reading of data"
      ]
   },
   {
      "q": "What is theft of service?",
      "c": [
         "This type of violation involves unauthorized reading of data",
         "This violation involves unauthorized modification of data",
         "This violation involves unauthorized destruction of data",
         "This violation involves unauthorized use of resources"
      ],
      "a": [
         "This violation involves unauthorized use of resources"
      ]
   },
   {
      "q": "What is breach of availability?",
      "c": [
         "This type of violation involves unauthorized reading of data",
         "This violation involves unauthorized modification of data",
         "This violation involves unauthorized destruction of data",
         "This violation involves unauthorized use of resources"
      ],
      "a": [
         "This violation involves unauthorized destruction of data"
      ]
   },
   {
      "q": "What is Trojan horse?",
      "c": [
         "It is a useful way to encrypt password",
         "It is a user which steals valuable information",
         "It is a rogue program which tricks users",
         "It\u2019s a brute force attack algorithm"
      ],
      "a": [
         "It is a rogue program which tricks users"
      ]
   },
   {
      "q": "What is trap door?",
      "c": [
         "It is trap door in WarGames",
         "It is a hole in software left by designer",
         "It is a Trojan horse",
         "It is a virus which traps and locks user terminal"
      ],
      "a": [
         "It is a hole in software left by designer"
      ]
   },
   {
      "q": "Which mechanism is used by worm process?",
      "c": [
         "Trap door",
         "Fake process",
         "Spawn Process",
         "VAX process"
      ],
      "a": [
         "Spawn Process"
      ]
   },
   {
      "q": "What is port scanning?",
      "c": [
         "It is a software used to scan system for attack",
         "It is a software application designed to probe a server or host for open ports",
         "It is software used to scan system for introducing attacks by brute force",
         "None of the mentioned"
      ],
      "a": [
         "It is a software application designed to probe a server or host for open ports"
      ]
   },
   {
      "q": "What are zombie systems?",
      "c": [
         "Are specific system which are designed to attack by manufacturer",
         "They are network of known hacking group",
         "These systems are previously compromised, independent systems",
         "None of the mentioned"
      ],
      "a": [
         "These systems are previously compromised, independent systems"
      ]
   },
   {
      "q": "What is used to protect network from outside internet access?",
      "c": [
         "A trusted antivirus",
         "24 hours scanning for virus",
         "Firewall to separate trusted and untrusted network",
         "Deny users access to websites which can potentially cause security leak"
      ],
      "a": [
         "Firewall to separate trusted and untrusted network"
      ]
   },
   {
      "q": "What is best practice in firewall domain environment?",
      "c": [
         "Create two domain trusted and untrusted domain",
         "Create strong policy in firewall to support different types of users",
         "Create a Demilitarized zone",
         "Create two DMZ zones with one untrusted domain"
      ],
      "a": [
         "Create a Demilitarized zone"
      ]
   },
   {
      "q": "Which direction access cannot happen using DMZ zone by default?",
      "c": [
         "Company computer to DMZ",
         "Internet to DMZ",
         "Internet to company computer",
         "Company computer to internet"
      ],
      "a": [
         "Internet to company computer"
      ]
   },
   {
      "q": "What are features of a tripwire file system?",
      "c": [
         "It is a tool to monitor file systems",
         "It is used to automatically take corrective action",
         "It is used to secure UNIX system",
         "None of the mentioned"
      ],
      "a": [
         "It is a tool to monitor file systems"
      ]
   },
   {
      "q": "What is known as sandbox?",
      "c": [
         "It is a program which can be molded to do desired task",
         "It is program that is controlled or emulated section of OS",
         "It is a special mode of antivirus",
         "None of the mentioned"
      ],
      "a": [
         "It is program that is controlled or emulated section of OS"
      ]
   },
   {
      "q": "What are the different ways to intrude?",
      "c": [
         "Buffer overflows",
         "Unexpected combinations and unhandled input",
         "Race conditions",
         "All of the mentioned"
      ],
      "a": [
         "All of the mentioned"
      ]
   },
   {
      "q": "What are drawbacks of the host based IDS?",
      "c": [
         "Unselective logging of messages may increase the audit burdens",
         "Selective logging runs the risk of missed attacks",
         "They are very fast to detect",
         "They have to be programmed for new patterns"
      ],
      "a": [
         "Unselective logging of messages may increase the audit burdens"
      ]
   },
   {
      "q": "Which one of the following is not a secondary storage?",
      "c": [
         "Magnetic disks",
         "Magnetic tapes",
         "RAM",
         "None of the mentioned"
      ],
      "a": [
         "RAM"
      ]
   },
   {
      "q": "The time for the disk arm to move the heads to the cylinder containing the desired sector is called:",
      "c": [
         "disk time",
         "seek time",
         "arm time",
         "sector time"
      ],
      "a": [
         "seek time"
      ]
   },
   {
      "q": "Which algorithm of disk scheduling selects the request with the least seek time from the current head positions?",
      "c": [
         "SSTF scheduling",
         "FCFS scheduling",
         "SCAN scheduling",
         "LOOK scheduling"
      ],
      "a": [
         "SSTF scheduling"
      ]
   },
   {
      "q": "A swap space can reside in:",
      "c": [
         "Separate disk partition",
         "RAM",
         "Cache",
         "None of the mentioned"
      ],
      "a": [
         "Separate disk partition"
      ]
   },
   {
      "q": "RAID level 1 refers to:",
      "c": [
         "disk arrays with striping",
         "disk mirroring",
         "both disk arrays with striping and disk mirroring",
         "none of the mentioned"
      ],
      "a": [
         "disk mirroring"
      ]
   },
   {
      "q": "When we write something on the disk, which one of the following can not happen?",
      "c": [
         "successful completion",
         "partial failure",
         "total failure",
         "none of the mentioned"
      ],
      "a": [
         "none of the mentioned"
      ]
   },
   {
      "q": "During recovery from a failure:",
      "c": [
         "each pair of physical block is examined",
         "specified pair of physical block is examined",
         "first pair of physical block is examined",
         "none of the mentioned"
      ],
      "a": [
         "each pair of physical block is examined"
      ]
   },
   {
      "q": "The replacement of a bad block generally is not totally automatic because:",
      "c": [
         "data in bad block can not be replaced",
         "data in bad block is usually lost",
         "bad block does not contain any data",
         "none of the mentioned"
      ],
      "a": [
         "data in bad block is usually lost"
      ]
   },
   {
      "q": "The first process launched by the linux kernel is:",
      "c": [
         "init process",
         "zombie process",
         "batch process",
         "boot process"
      ],
      "a": [
         "init process"
      ]
   },
   {
      "q": "Standard set of functions through which interacts with kernel is defined by:",
      "c": [
         "system libraries",
         "kernel code",
         "compilers",
         "utility programs"
      ],
      "a": [
         "system libraries"
      ]
   },
   {
      "q": "Which one of the following is not shared by threads?",
      "c": [
         "program counter",
         "stack",
         "both program counter and stack",
         "none of the mentioned"
      ],
      "a": [
         "both program counter and stack"
      ]
   },
   {
      "q": "A process can be:",
      "c": [
         "single threaded",
         "multithreaded",
         "both single threaded and multithreaded",
         "none of the mentioned"
      ],
      "a": [
         "both single threaded and multithreaded"
      ]
   },
   {
      "q": "If one thread opens a file with read privileges then:",
      "c": [
         "other threads in the another process can also read from that file",
         "other threads in the same process can also read from that file",
         "any other thread can not read from that file",
         "all of the mentioned"
      ],
      "a": [
         "other threads in the same process can also read from that file"
      ]
   },
   {
      "q": "The time required to create a new thread in an existing process is:",
      "c": [
         "greater than the time required to create a new process",
         "less than the time required to create a new process",
         "equal to the time required to create a new process",
         "none of the mentioned"
      ],
      "a": [
         "less than the time required to create a new process"
      ]
   },
   {
      "q": "When the event for which a thread is blocked occurs:",
      "c": [
         "thread moves to the ready queue",
         "thread remains blocked",
         "thread completes",
         "a new thread is provided"
      ],
      "a": [
         "thread moves to the ready queue"
      ]
   },
   {
      "q": "Termination of the process terminates:",
      "c": [
         "first thread of the process",
         "first two threads of the process",
         "all threads within the process",
         "no thread within the process"
      ],
      "a": [
         "all threads within the process"
      ]
   },
   {
      "q": "Which one of the following is not a valid state of a thread?",
      "c": [
         "running",
         "parsing",
         "ready",
         "blocked"
      ],
      "a": [
         "parsing"
      ]
   },
   {
      "q": "The register context and stacks of a thread are deallocated when the thread:",
      "c": [
         "terminates",
         "blocks",
         "unblocks",
         "spawns"
      ],
      "a": [
         "terminates"
      ]
   },
   {
      "q": "A thread is also called:",
      "c": [
         "Light Weight Process(LWP)",
         "Heavy Weight Process(HWP)",
         "Process",
         "None of the mentioned"
      ],
      "a": [
         "Light Weight Process(LWP)"
      ]
   },
   {
      "q": "A thread shares its resources(like data section, code section, open files, signals) with:",
      "c": [
         "other process similar to the one that the thread belongs to",
         "other threads that belong to similar processes",
         "other threads that belong to the same process",
         "all of the mentioned"
      ],
      "a": [
         "other threads that belong to the same process"
      ]
   },
   {
      "q": "A heavy weight process:",
      "c": [
         "has multiple threads of execution",
         "has a single thread of execution",
         "can have multiple or a single thread for execution",
         "none of the mentioned"
      ],
      "a": [
         "has a single thread of execution"
      ]
   },
   {
      "q": "A process having multiple threads of control implies:",
      "c": [
         "it can do more than one task at a time",
         "it can do only one task at a time, but much faster",
         "it has to use only one thread per process",
         "none of the mentioned"
      ],
      "a": [
         "it can do more than one task at a time"
      ]
   },
   {
      "q": "Multithreading an interactive program will increase responsiveness to the user by:",
      "c": [
         "continuing to run even if a part of it is blocked",
         "waiting for one part to finish before the other begins",
         "asking the user to decide the order of multithreading",
         "none of the mentioned"
      ],
      "a": [
         "continuing to run even if a part of it is blocked"
      ]
   },
   {
      "q": "Resource sharing helps:",
      "c": [
         "share the memory and resources of the process to which the threads belong",
         "an application have several different threads of activity all within the same address space",
         "reduce the address space that a process could potentially use",
         "all of the mentioned"
      ],
      "a": [
         "all of the mentioned"
      ]
   },
   {
      "q": "Multithreading on a multi \u2013 CPU machine:",
      "c": [
         "decreases concurrency",
         "increases concurrency",
         "doesn\u2019t affect the concurrency",
         "can increase or decrease the concurrency"
      ],
      "a": [
         "increases concurrency"
      ]
   },
   {
      "q": "The kernel is --?-- of user threads.",
      "c": [
         "a part of",
         "the creator of",
         "unaware of",
         "aware of"
      ],
      "a": [
         "unaware of"
      ]
   },
   {
      "q": "If the kernel is single threaded, then any user level thread performing a blocking system call will:",
      "c": [
         "cause the entire process to run along with the other threads",
         "cause the thread to block with the other threads running",
         "cause the entire process to block even if the other threads are available to run",
         "none of the mentioned"
      ],
      "a": [
         "cause the entire process to block even if the other threads are available to run"
      ]
   },
   {
      "q": "Because the kernel thread management is done by the Operating System itself:",
      "c": [
         "kernel threads are faster to create than user threads",
         "kernel threads are slower to create than user threads",
         "kernel threads are easier to manage as well as create then user threads",
         "none of the mentioned"
      ],
      "a": [
         "kernel threads are slower to create than user threads"
      ]
   },
   {
      "q": "If a kernel thread performs a blocking system call:",
      "c": [
         "the kernel can schedule another thread in the application for execution",
         "the kernel cannot schedule another thread in the same application for execution",
         "the kernel must schedule another thread of a different application for execution",
         "the kernel must schedule another thread of the same application on a different processor"
      ],
      "a": [
         "the kernel can schedule another thread in the application for execution"
      ]
   },
   {
      "q": "Which of the following is FALSE?",
      "c": [
         "Context switch time is longer for kernel level threads than for user level threads",
         "User level threads do not need any hardware support",
         "Related kernel level threads can be scheduled on different processors in a multiprocessor system",
         "Blocking one kernel level thread blocks all other related threads"
      ],
      "a": [
         "Blocking one kernel level thread blocks all other related threads"
      ]
   },
   {
      "q": "In the Many to One model, if a thread makes a blocking system call:",
      "c": [
         "the entire process will be blocked",
         "a part of the process will stay blocked, with the rest running",
         "the entire process will run",
         "none of the mentioned"
      ],
      "a": [
         "the entire process will be blocked"
      ]
   },
   {
      "q": "In the Many to One model, multiple threads are unable to run in parallel on multiprocessors because:",
      "c": [
         "only one thread can access the kernel at a time",
         "many user threads have access to just one kernel thread",
         "there is only one kernel thread",
         "none of the mentioned"
      ],
      "a": [
         "only one thread can access the kernel at a time"
      ]
   },
   {
      "q": "The One to One model allows:",
      "c": [
         "increased concurrency",
         "decreased concurrency",
         "increased or decreased concurrency",
         "concurrency equivalent to other models"
      ],
      "a": [
         "increased concurrency"
      ]
   },
   {
      "q": "In the One to One model when a thread makes a blocking system call:",
      "c": [
         "other threads are strictly prohibited from running",
         "other threads are allowed to run",
         "other threads only from other processes are allowed to run",
         "none of the mentioned"
      ],
      "a": [
         "other threads are allowed to run"
      ]
   },
   {
      "q": "Which of the following is the drawback of the One to One Model?",
      "c": [
         "increased concurrency provided by this model",
         "decreased concurrency provided by this model",
         "creating so many threads at once can crash the system",
         "creating a user thread requires creating the corresponding kernel thread"
      ],
      "a": [
         "creating a user thread requires creating the corresponding kernel thread"
      ]
   },
   {
      "q": "When is the Many to One model at an advantage?",
      "c": [
         "When the program does not need multithreading",
         "When the program has to be multi-threaded",
         "When there is a single processor",
         "None of the mentioned"
      ],
      "a": [
         "When the program does not need multithreading"
      ]
   },
   {
      "q": "In the Many to Many model true concurrency cannot be gained because:",
      "c": [
         "the kernel can schedule only one thread at a time",
         "there are too many threads to handle",
         "it is hard to map threads with each other",
         "none of the mentioned"
      ],
      "a": [
         "the kernel can schedule only one thread at a time"
      ]
   },
   {
      "q": "In the Many to Many model when a thread performs a blocking system call:",
      "c": [
         "other threads are strictly prohibited from running",
         "other threads are allowed to run",
         "other threads only from other processes are allowed to run",
         "none of the mentioned"
      ],
      "a": [
         "other threads are allowed to run"
      ]
   },
   {
      "q": "Which of the following system calls does not return control to the calling point, on termination?",
      "c": [
         "fork",
         "exec",
         "ioctl",
         "longjmp"
      ],
      "a": [
         "exec"
      ]
   },
   {
      "q": "Which of the following system calls transforms executable binary file into a process?",
      "c": [
         "fork",
         "exec",
         "ioctl",
         "longjmp"
      ],
      "a": [
         "exec"
      ]
   },
   {
      "q": "Which of the following calls never returns an error?",
      "c": [
         "getpid",
         "fork",
         "ioctl",
         "open"
      ],
      "a": [
         "getpid"
      ]
   },
   {
      "q": "A fork system call will fail if:",
      "c": [
         "the previously executed statement is also a fork call",
         "the limit on the maximum number of processes in the system would be executed",
         "the limit on the minimum number of processes that can be under execution by a single user would be executed",
         "all of the mentioned"
      ],
      "a": [
         "the limit on the maximum number of processes in the system would be executed"
      ]
   },
   {
      "q": "If a thread invokes the exec system call:",
      "c": [
         "only the exec executes as a separate process.",
         "the program specified in the parameter to exec will replace the entire process",
         "the exec is ignored as it is invoked by a thread.",
         "none of the mentioned"
      ],
      "a": [
         "the program specified in the parameter to exec will replace the entire process"
      ]
   },
   {
      "q": "If exec is called immediately after forking:",
      "c": [
         "the program specified in the parameter to exec will replace the entire process",
         "all the threads will be duplicated",
         "all the threads may be duplicated",
         "none of the mentioned"
      ],
      "a": [
         "the program specified in the parameter to exec will replace the entire process"
      ]
   },
   {
      "q": "If a process does not call exec after forking:",
      "c": [
         "the program specified in the parameter to exec will replace the entire process",
         "all the threads should be duplicated",
         "all the threads should not be duplicated",
         "none of the mentioned"
      ],
      "a": [
         "all the threads should be duplicated"
      ]
   },
   {
      "q": "Thread cancellation is:",
      "c": [
         "the task of destroying the thread once its work is done",
         "the task of removing a thread once its work is done",
         "the task of terminating a thread before it has completed",
         "none of the mentioned"
      ],
      "a": [
         "the task of terminating a thread before it has completed"
      ]
   },
   {
      "q": "When a web page is loading, and the user presses a button on the browser to stop loading the page:",
      "c": [
         "the thread loading the page continues with the loading",
         "the thread loading the page does not stop, but continues with another task",
         "the thread loading the page is paused",
         "the thread loading the page is cancelled"
      ],
      "a": [
         "the thread loading the page is cancelled"
      ]
   },
   {
      "q": "When one thread immediately terminates the target thread, it is called:",
      "c": [
         "Asynchronous cancellation",
         "Systematic cancellation",
         "Sudden Termination",
         "Deferred cancellation"
      ],
      "a": [
         "Asynchronous cancellation"
      ]
   },
   {
      "q": "When the target thread periodically checks if it should terminate and terminates itself in an orderly manner, it is called:",
      "c": [
         "Asynchronous cancellation",
         "Systematic cancellation",
         "Sudden Termination",
         "Deferred cancellation"
      ],
      "a": [
         "Deferred cancellation"
      ]
   },
   {
      "q": "Cancelling a thread asynchronously:",
      "c": [
         "frees all the resources properly",
         "may not free each resource",
         "spoils the process execution",
         "none of the mentioned"
      ],
      "a": [
         "may not free each resource"
      ]
   },
   {
      "q": "Cancellation point is the point where:",
      "c": [
         "the thread can be cancelled \u2013 safely or otherwise doesn\u2019t matter",
         "the thread can be cancelled safely",
         "the whole process can be cancelled safely",
         "none of the mentioned"
      ],
      "a": [
         "the thread can be cancelled safely"
      ]
   },
   {
      "q": "If multiple threads are concurrently searching through a database and one thread returns the result then the remaining threads must be:",
      "c": [
         "continued",
         "cancelled",
         "protected",
         "none of the mentioned"
      ],
      "a": [
         "cancelled"
      ]
   },
   {
      "q": "Signals that occur at the same time, are presented to the process:",
      "c": [
         "one at a time, in a particular order",
         "one at a time, in no particular order",
         "all at a time",
         "none of the mentioned"
      ],
      "a": [
         "one at a time, in no particular order"
      ]
   },
   {
      "q": "Which of the following is not TRUE:",
      "c": [
         "Processes may send each other signals",
         "Kernel may send signals internally",
         "a field is updated in the signal table when the signal is sent",
         "each signal is maintained by a single bit"
      ],
      "a": [
         "a field is updated in the signal table when the signal is sent"
      ]
   },
   {
      "q": "Signals of a given type:",
      "c": [
         "are queued",
         "are all sent as one",
         "cannot be queued",
         "none of the mentioned"
      ],
      "a": [
         "are all sent as one"
      ]
   },
   {
      "q": "The way/s in which a process responds to a signal are:",
      "c": [
         "ignoring the signal",
         "handling the signal",
         "performing some default action",
         "all of the mentioned"
      ],
      "a": [
         "all of the mentioned"
      ]
   },
   {
      "q": "Signals are identified by:",
      "c": [
         "signal identifiers",
         "signal handlers",
         "signal actions",
         "none of the mentioned"
      ],
      "a": [
         "signal identifiers"
      ]
   },
   {
      "q": "When a process blocks the receipt of certain signals:",
      "c": [
         "The signals are delivered",
         "The signals are not delivered",
         "The signals are received until they are unblocked",
         "The signals are received by the process once they are delivered"
      ],
      "a": [
         "The signals are delivered"
      ]
   },
   {
      "q": "The --?-- maintains pending and blocked bit vectors in context of each process.",
      "c": [
         "CPU",
         "Memory",
         "Process",
         "Kernel"
      ],
      "a": [
         "Kernel"
      ]
   },
   {
      "q": "The usefulness of signals as a general inter process communication mechanism is limited because:",
      "c": [
         "they do not work between processes",
         "they are user generated",
         "they cannot carry information directly",
         "none of the mentioned"
      ],
      "a": [
         "they cannot carry information directly"
      ]
   },
   {
      "q": "The usual effect of abnormal termination of a program is:",
      "c": [
         "core dump file generation",
         "system crash",
         "program switch",
         "signal destruction"
      ],
      "a": [
         "core dump file generation"
      ]
   },
   {
      "q": "In most cases, if a process is sent a signal while it is executing a system call:",
      "c": [
         "the system call will continue execution and the signal will be ignored completely",
         "the system call is interrupted by the signal, and the signal handler comes in",
         "the signal has no effect until the system call completes",
         "none of the mentioned"
      ],
      "a": [
         "the signal has no effect until the system call completes"
      ]
   },
   {
      "q": "A process can never be sure that a signal it has sent:",
      "c": [
         "has which identifier",
         "has not been lost",
         "has been sent",
         "all of the mentioned"
      ],
      "a": [
         "has not been lost"
      ]
   },
   {
      "q": "In UNIX, the --?-- system call is used to send a signal.",
      "c": [
         "sig",
         "send",
         "kill",
         "sigsend"
      ],
      "a": [
         "kill"
      ]
   },
   {
      "q": "Thread pools are useful when:",
      "c": [
         "when we need to limit the number of threads running in the application at the same time",
         "when we need to limit the number of threads running in the application as a whole",
         "when we need to arrange the ordering of threads",
         "none of the mentioned"
      ],
      "a": [
         "when we need to limit the number of threads running in the application at the same time"
      ]
   },
   {
      "q": "Instead of starting a new thread for every task to execute concurrently, the task can be passed to a:",
      "c": [
         "process",
         "thread pool",
         "thread queue",
         "none of the mentioned"
      ],
      "a": [
         "thread pool"
      ]
   },
   {
      "q": "Each connection arriving at multi threaded servers via network is generally:",
      "c": [
         "is directly put into the blocking queue",
         "is wrapped as a task and passed on to a thread pool",
         "is kept in a normal queue and then sent to the blocking queue from where it is dequeued",
         "none of the mentioned"
      ],
      "a": [
         "is wrapped as a task and passed on to a thread pool"
      ]
   },
   {
      "q": "The idea behind thread pools is:",
      "c": [
         "a number of threads are created at process startup and placed in a pool where they sit and wait for work",
         "when a process begins, a pool of threads is chosen from the many existing and each thread is allotted equal amount of work",
         "all threads in a pool distribute the task equally among themselves",
         "none of the mentioned"
      ],
      "a": [
         "a number of threads are created at process startup and placed in a pool where they sit and wait for work"
      ]
   },
   {
      "q": "If the thread pool contains no available thread:",
      "c": [
         "the server runs a new process",
         "the server goes to another thread pool",
         "the server demands for a new pool creation",
         "the server waits until one becomes free"
      ],
      "a": [
         "the server waits until one becomes free"
      ]
   },
   {
      "q": "Thread pools help in:",
      "c": [
         "servicing multiple requests using one thread",
         "servicing a single request using multiple threads from the pool",
         "faster servicing of requests with an existing thread rather than waiting to create a new thread",
         "none of the mentioned"
      ],
      "a": [
         "faster servicing of requests with an existing thread rather than waiting to create a new thread"
      ]
   },
   {
      "q": "Thread pools limit the number of threads that exist at any one point, hence:",
      "c": [
         "not letting the system resources like CPU time and memory exhaust",
         "helping a limited number of processes at a time",
         "not serving all requests and ignoring many",
         "none of the mentioned"
      ],
      "a": [
         "not letting the system resources like CPU time and memory exhaust"
      ]
   },
   {
      "q": "The number of the threads in the pool can be decided on factors such as:",
      "c": [
         "number of CPUs in the system",
         "amount of physical memory",
         "expected number of concurrent client requests",
         "all of the mentioned"
      ],
      "a": [
         "all of the mentioned"
      ]
   },
   {
      "q": "Because of virtual memory, the memory can be shared among:",
      "c": [
         "processes",
         "threads",
         "instructions",
         "none of the mentioned"
      ],
      "a": [
         "processes"
      ]
   },
   {
      "q": "_____ is the concept in which a process is copied into main memory from the secondary memory according to the requirement.",
      "c": [
         "Paging",
         "Demand paging",
         "Segmentation",
         "Swapping"
      ],
      "a": [
         "Demand paging"
      ]
   },
   {
      "q": "The pager concerns with the:",
      "c": [
         "individual page of a process",
         "entire process",
         "entire thread",
         "first page of a process"
      ],
      "a": [
         "individual page of a process"
      ]
   },
   {
      "q": "Swap space exists in:",
      "c": [
         "primary memory",
         "secondary memory",
         "cpu",
         "none of the mentioned"
      ],
      "a": [
         "secondary memory"
      ]
   },
   {
      "q": "When a program tries to access a page that is mapped in address space but not loaded in physical memory, then:",
      "c": [
         "segmentation fault occurs",
         "fatal error occurs",
         "page fault occurs",
         "no error occurs"
      ],
      "a": [
         "page fault occurs"
      ]
   },
   {
      "q": "Effective access time is directly proportional to:",
      "c": [
         "page-fault rate",
         "hit ratio",
         "memory access time",
         "none of the mentioned"
      ],
      "a": [
         "page-fault rate"
      ]
   },
   {
      "q": "In FIFO page replacement algorithm, when a page must be replaced:",
      "c": [
         "oldest page is chosen",
         "newest page is chosen",
         "random page is chosen",
         "none of the mentioned"
      ],
      "a": [
         "oldest page is chosen"
      ]
   },
   {
      "q": "A process is thrashing if:",
      "c": [
         "it is spending more time paging than executing",
         "it is spending less time paging than executing",
         "page fault occurs",
         "swapping can not take place"
      ],
      "a": [
         "it is spending more time paging than executing"
      ]
   },
   {
      "q": "Working set model for page replacement is based on the assumption of:",
      "c": [
         "modularity",
         "locality",
         "globalization",
         "random access"
      ],
      "a": [
         "locality"
      ]
   },
   {
      "q": "Virtual memory allows:",
      "c": [
         "execution of a process that may not be completely in memory",
         "a program to be smaller than the physical memory",
         "a program to be larger than the secondary storage",
         "execution of a process without being in physical memory"
      ],
      "a": [
         "execution of a process that may not be completely in memory"
      ]
   },
   {
      "q": "The instruction being executed, must be in:",
      "c": [
         "physical memory",
         "logical memory",
         "physical & logical memory",
         "none of the mentioned"
      ],
      "a": [
         "physical memory"
      ]
   },
   {
      "q": "Error handler codes, to handle unusual errors are:",
      "c": [
         "almost never executed",
         "executed very often",
         "executed periodically",
         "none of the mentioned"
      ],
      "a": [
         "almost never executed"
      ]
   },
   {
      "q": "The ability to execute a program that is only partially in memory has benefits like:",
      "c": [
         "The amount of physical memory cannot put a constraint on the program",
         "Programs for an extremely large virtual space can be created",
         "Throughput increases",
         "All of the mentioned"
      ],
      "a": [
         "All of the mentioned"
      ]
   },
   {
      "q": "In virtual memory. the programmer --?-- of overlays.",
      "c": [
         "has to take care",
         "does not have to take care",
         "all of the mentioned",
         "none of the mentioned"
      ],
      "a": [
         "does not have to take care"
      ]
   },
   {
      "q": "Virtual memory is normally implemented by:",
      "c": [
         "demand paging",
         "buses",
         "virtualization",
         "all of the mentioned"
      ],
      "a": [
         "demand paging"
      ]
   },
   {
      "q": "Segment replacement algorithms are more complex than page replacement algorithms because:",
      "c": [
         "Segments are better than pages",
         "Pages are better than segments",
         "Segments have variable sizes",
         "Segments have fixed sizes"
      ],
      "a": [
         "Segments have variable sizes"
      ]
   },
   {
      "q": "A swapper manipulates --?-- whereas the pager is concerned with individual --?-- of a process.",
      "c": [
         "the entire process, parts",
         "all the pages of a process, segments",
         "the entire process, pages",
         "none of the mentioned"
      ],
      "a": [
         "the entire process, pages"
      ]
   },
   {
      "q": "Using a pager:",
      "c": [
         "increases the swap time",
         "decreases the swap time",
         "decreases the swap time & amount of physical memory needed",
         "increases the amount of physical memory needed"
      ],
      "a": [
         "decreases the swap time & amount of physical memory needed"
      ]
   },
   {
      "q": "The valid \u2013 invalid bit, in this case, when valid indicates:",
      "c": [
         "the page is not legal",
         "the page is illegal",
         "the page is in memory",
         "the page is not in memory"
      ],
      "a": [
         "the page is in memory"
      ]
   },
   {
      "q": "A page fault occurs when:",
      "c": [
         "a page gives inconsistent data",
         "a page cannot be accessed due to its absence from memory",
         "a page is invisible",
         "all of the mentioned"
      ],
      "a": [
         "a page cannot be accessed due to its absence from memory"
      ]
   },
   {
      "q": "When a page fault occurs, the state of the interrupted process is:",
      "c": [
         "disrupted",
         "invalid",
         "saved",
         "none of the mentioned"
      ],
      "a": [
         "saved"
      ]
   },
   {
      "q": "When a page is selected for replacement, and its modify bit is set:",
      "c": [
         "the page is clean",
         "the page has been modified since it was read in from the disk",
         "the page is dirty",
         "the page has been modified since it was read in from the disk & page is dirty"
      ],
      "a": [
         "the page has been modified since it was read in from the disk & page is dirty"
      ]
   },
   {
      "q": "The aim of creating page replacement algorithms is to:",
      "c": [
         "replace pages faster",
         "increase the page fault rate",
         "decrease the page fault rate",
         "to allocate multiple pages to processes"
      ],
      "a": [
         "decrease the page fault rate"
      ]
   },
   {
      "q": "Optimal page \u2013 replacement algorithm is difficult to implement, because:",
      "c": [
         "it requires a lot of information",
         "it requires future knowledge of the reference string",
         "it is too complex",
         "it is extremely expensive"
      ],
      "a": [
         "it requires future knowledge of the reference string"
      ]
   },
   {
      "q": "The two methods how LRU page replacement policy can be implemented in hardware are:",
      "c": [
         "Counters & Registers",
         "RAM & Registers",
         "Stack & Counters",
         "Registers & RAM"
      ],
      "a": [
         "Stack & Counters"
      ]
   },
   {
      "q": "When using counters to implement LRU, we replace the page with the:",
      "c": [
         "smallest time value",
         "largest time value",
         "greatest size",
         "none of the mentioned"
      ],
      "a": [
         "smallest time value"
      ]
   },
   {
      "q": "In the stack implementation of the LRU algorithm, a stack can be maintained in a manner:",
      "c": [
         "whenever a page is used, it is removed from the stack and put on bottom",
         "the bottom of the stack is the LRU page",
         "the top of the stack contains the LRU page and all new pages are added to the top",
         "none of the mentioned"
      ],
      "a": [
         "the bottom of the stack is the LRU page"
      ]
   },
   {
      "q": "There is a set of page replacement algorithms that can never exhibit Belady\u2019s Anomaly, called:",
      "c": [
         "queue algorithms",
         "stack algorithms",
         "string algorithms",
         "none of the mentioned"
      ],
      "a": [
         "stack algorithms"
      ]
   },
   {
      "q": "Increasing the RAM of a computer typically improves performance because:",
      "c": [
         "Virtual memory increases",
         "Larger RAMs are faster",
         "Fewer page faults occur",
         "None of the mentioned"
      ],
      "a": [
         "Fewer page faults occur"
      ]
   },
   {
      "q": "The essential content(s) in each entry of a page table is / are:",
      "c": [
         "Virtual page number",
         "Page frame number",
         "Both virtual page number and page frame number",
         "Access right information"
      ],
      "a": [
         "Page frame number"
      ]
   },
   {
      "q": "The minimum number of page frames that must be allocated to a running process in a virtual memory environment is determined by:",
      "c": [
         "the instruction set architecture",
         "page size",
         "physical memory size",
         "number of processes in memory"
      ],
      "a": [
         "the instruction set architecture"
      ]
   },
   {
      "q": "The reason for using the LFU page replacement algorithm is:",
      "c": [
         "an actively used page should have a large reference count",
         "a less used page has more chances to be used again",
         "it is extremely efficient and optimal",
         "all of the mentioned"
      ],
      "a": [
         "an actively used page should have a large reference count"
      ]
   },
   {
      "q": "The implementation of the LFU and the MFU algorithm is very uncommon because:",
      "c": [
         "they are too complicated",
         "they are optimal",
         "they are expensive",
         "all of the mentioned"
      ],
      "a": [
         "they are expensive"
      ]
   },
   {
      "q": "The minimum number of frames to be allocated to a process is decided by the:",
      "c": [
         "the amount of available physical memory",
         "operating System",
         "instruction set architecture",
         "none of the mentioned"
      ],
      "a": [
         "instruction set architecture"
      ]
   },
   {
      "q": "When a page fault occurs before an executing instruction is complete:",
      "c": [
         "the instruction must be restarted",
         "the instruction must be ignored",
         "the instruction must be completed ignoring the page fault",
         "none of the mentioned"
      ],
      "a": [
         "the instruction must be restarted"
      ]
   },
   {
      "q": "Consider a machine in which all memory reference instructions have only one memory address, for them we need at least --?-- frame(s).",
      "c": [
         "one",
         "two",
         "three",
         "none of the mentioned"
      ],
      "a": [
         "two"
      ]
   },
   {
      "q": "The maximum number of frames per process is defined by:",
      "c": [
         "the amount of available physical memory",
         "operating System",
         "instruction set architecture",
         "none of the mentioned"
      ],
      "a": [
         "the amount of available physical memory"
      ]
   },
   {
      "q": "--?-- replacement allows a process to select a replacement frame from the set of all frames, even if the frame is currently allocated to some other process.",
      "c": [
         "Local",
         "Universal",
         "Global",
         "Public"
      ],
      "a": [
         "Global"
      ]
   },
   {
      "q": "--?-- replacement allows each process to only select from its own set of allocated frames.",
      "c": [
         "Local",
         "Universal",
         "Global",
         "Public"
      ],
      "a": [
         "Local"
      ]
   },
   {
      "q": "One problem with the global replacement algorithm is that:",
      "c": [
         "it is very expensive",
         "many frames can be allocated to a process",
         "only a few frames can be allocated to a process",
         "a process cannot control its own page \u2013 fault rate"
      ],
      "a": [
         "a process cannot control its own page \u2013 fault rate"
      ]
   },
   {
      "q": "--?-- replacement generally results in greater system throughput.",
      "c": [
         "Local",
         "Global",
         "Universal",
         "Public"
      ],
      "a": [
         "Global"
      ]
   },
   {
      "q": "A process is thrashing if:",
      "c": [
         "it spends a lot of time executing, rather than paging",
         "it spends a lot of time paging, than executing",
         "it has no memory allocated to it",
         "none of the mentioned"
      ],
      "a": [
         "it spends a lot of time paging, than executing"
      ]
   },
   {
      "q": "Thrashing --?-- the CPU utilization.",
      "c": [
         "increases",
         "keeps constant",
         "decreases",
         "none of the mentioned"
      ],
      "a": [
         "decreases"
      ]
   },
   {
      "q": "A locality is:",
      "c": [
         "a set of pages that are actively used together",
         "a space in memory",
         "an area near a set of processes",
         "none of the mentioned"
      ],
      "a": [
         "a set of pages that are actively used together"
      ]
   },
   {
      "q": "When a subroutine is called:",
      "c": [
         "it defines a new locality",
         "it is in the same locality from where it was called",
         "it does not define a new locality",
         "none of the mentioned"
      ],
      "a": [
         "it defines a new locality"
      ]
   },
   {
      "q": "A program is generally composed of several different localities, which --?-- overlap.",
      "c": [
         "may",
         "must",
         "do not",
         "must not"
      ],
      "a": [
         "may"
      ]
   },
   {
      "q": "The accuracy of the working set depends on the selection of:",
      "c": [
         "working set model",
         "working set size",
         "memory size",
         "number of pages in memory"
      ],
      "a": [
         "working set size"
      ]
   },
   {
      "q": "If working set window is too small:",
      "c": [
         "it will not encompass entire locality",
         "it may overlap several localities",
         "it will cause memory problems",
         "none of the mentioned"
      ],
      "a": [
         "it will not encompass entire locality"
      ]
   },
   {
      "q": "If working set window is too large:",
      "c": [
         "it will not encompass entire locality",
         "it may overlap several localities",
         "it will cause memory problems",
         "none of the mentioned"
      ],
      "a": [
         "it may overlap several localities"
      ]
   },
   {
      "q": "If the sum of the working \u2013 set sizes increases, exceeding the total number of available frames:",
      "c": [
         "then the process crashes",
         "the memory overflows",
         "the system crashes",
         "the operating system selects a process to suspend"
      ],
      "a": [
         "the operating system selects a process to suspend"
      ]
   },
   {
      "q": "--?-- is a unique tag, usually a number, identifies the file within the file system.",
      "c": [
         "File identifier",
         "File name",
         "File type",
         "None of the mentioned"
      ],
      "a": [
         "File identifier"
      ]
   },
   {
      "q": "To create a file:",
      "c": [
         "allocate the space in file system",
         "make an entry for new file in directory",
         "allocate the space in file system & make an entry for new file in directory",
         "none of the mentioned"
      ],
      "a": [
         "allocate the space in file system & make an entry for new file in directory"
      ]
   },
   {
      "q": "By using the specific system call, we can:",
      "c": [
         "open the file",
         "read the file",
         "write into the file",
         "all of the mentioned"
      ],
      "a": [
         "all of the mentioned"
      ]
   },
   {
      "q": "File type can be represented by:",
      "c": [
         "file name",
         "file extension",
         "file identifier",
         "none of the mentioned"
      ],
      "a": [
         "file extension"
      ]
   },
   {
      "q": "Which file is a sequence of bytes organized into blocks understandable by the system\u2019s linker?",
      "c": [
         "object file",
         "source file",
         "executable file",
         "text file"
      ],
      "a": [
         "object file"
      ]
   },
   {
      "q": "What is the mounting of file system?",
      "c": [
         "crating of a filesystem",
         "deleting a filesystem",
         "attaching portion of the file system into a directory structure",
         "removing portion of the file system into a directory structure"
      ],
      "a": [
         "attaching portion of the file system into a directory structure"
      ]
   },
   {
      "q": "Mapping of file is managed by:",
      "c": [
         "file metadata",
         "page table",
         "virtual memory",
         "file system"
      ],
      "a": [
         "file metadata"
      ]
   },
   {
      "q": "Mapping of network file system protocol to local file system is done by:",
      "c": [
         "network file system",
         "local file system",
         "volume manager",
         "remote mirror"
      ],
      "a": [
         "network file system"
      ]
   },
   {
      "q": "Which one of the following explains the sequential file access method?",
      "c": [
         "random access according to the given byte number",
         "read bytes one at a time, in order",
         "read/write sequentially by record",
         "read/write randomly by record"
      ],
      "a": [
         "read bytes one at a time, in order"
      ]
   },
   {
      "q": "File system fragmentation occurs when:",
      "c": [
         "unused space or single file are not contiguous",
         "used space is not contiguous",
         "unused space is non-contiguous",
         "multiple files are non-contiguous"
      ],
      "a": [
         "unused space or single file are not contiguous"
      ]
   },
   {
      "q": "Management of metadata information is done by:",
      "c": [
         "file-organisation module",
         "logical file system",
         "basic file system",
         "application programs"
      ],
      "a": [
         "logical file system"
      ]
   },
   {
      "q": "A file control block contains the information about:",
      "c": [
         "file ownership",
         "file permissions",
         "location of file contents",
         "all of the mentioned"
      ],
      "a": [
         "all of the mentioned"
      ]
   },
   {
      "q": "Which table contains the information about each mounted volume?",
      "c": [
         "mount table",
         "system-wide open-file table",
         "per-process open-file table",
         "all of the mentioned"
      ],
      "a": [
         "all of the mentioned"
      ]
   },
   {
      "q": "To create a new file application program calls:",
      "c": [
         "basic file system",
         "logical file system",
         "file-organisation module",
         "none of the mentioned"
      ],
      "a": [
         "logical file system"
      ]
   },
   {
      "q": "When a process closes the file:",
      "c": [
         "per-process table entry is not removed",
         "system wide entry\u2019s open count is decremented",
         "all of the mentioned",
         "none of the mentioned"
      ],
      "a": [
         "system wide entry\u2019s open count is decremented"
      ]
   },
   {
      "q": "What is raw disk?",
      "c": [
         "disk without file system",
         "empty disk",
         "disk lacking logical file system",
         "disk having file system"
      ],
      "a": [
         "disk without file system"
      ]
   },
   {
      "q": "The data structure used for file directory is called:",
      "c": [
         "mount table",
         "hash table",
         "file table",
         "process table"
      ],
      "a": [
         "hash table"
      ]
   },
   {
      "q": "In which type of allocation method each file occupy a set of contiguous block on the disk?",
      "c": [
         "contiguous allocation",
         "dynamic-storage allocation",
         "linked allocation",
         "indexed allocation"
      ],
      "a": [
         "contiguous allocation"
      ]
   },
   {
      "q": "Which protocol establishes the initial logical connection between a server and a client?",
      "c": [
         "transmission control protocol",
         "user datagram protocol",
         "mount protocol",
         "datagram congestion control protocol"
      ],
      "a": [
         "mount protocol"
      ]
   },
   {
      "q": "Data cannot be written to secondary storage unless written within a:",
      "c": [
         "file",
         "swap space",
         "directory",
         "text format"
      ],
      "a": [
         "file"
      ]
   },
   {
      "q": "File attributes consist of:",
      "c": [
         "name",
         "type",
         "identifier",
         "all of the mentioned"
      ],
      "a": [
         "all of the mentioned"
      ]
   },
   {
      "q": "The information about all files is kept in:",
      "c": [
         "swap space",
         "operating system",
         "seperate directory structure",
         "none of the mentioned"
      ],
      "a": [
         "seperate directory structure"
      ]
   },
   {
      "q": "A file is a/an --?-- data type.",
      "c": [
         "abstract",
         "primitive",
         "private"
      ],
      "a": [
         "abstract"
      ]
   },
   {
      "q": "The operating system keeps a small table containing information about all open files called:",
      "c": [
         "system table",
         "open-file table",
         "file table",
         "directory table"
      ],
      "a": [
         "open-file table"
      ]
   },
   {
      "q": "In UNIX, the open system call returns:",
      "c": [
         "pointer to the entry in the open file table",
         "pointer to the entry in the system wide table",
         "a file to the process calling it",
         "none of the mentioned"
      ],
      "a": [
         "pointer to the entry in the open file table"
      ]
   },
   {
      "q": "The open file table has a/an --?-- associated with each file.",
      "c": [
         "file content",
         "file permission",
         "open count",
         "close count"
      ],
      "a": [
         "open count"
      ]
   },
   {
      "q": "The file name is generally split into two parts:",
      "c": [
         "name & identifier",
         "identifier & type",
         "extension & name",
         "type & extension"
      ],
      "a": [
         "extension & name"
      ]
   },
   {
      "q": "The UNIX sytem uses a/an --?-- stored at the beginning of a some files to indicate roughly the type of file.",
      "c": [
         "identifier",
         "extension",
         "virtual number",
         "magic number"
      ],
      "a": [
         "magic number"
      ]
   },
   {
      "q": "The larger the block size, the --?-- the internal fragmentation.",
      "c": [
         "greater",
         "lesser",
         "same",
         "none of the mentioned"
      ],
      "a": [
         "greater"
      ]
   },
   {
      "q": "Sequential access method --?-- on random access devices.",
      "c": [
         "works well",
         "doesnt work well",
         "maybe works well and doesnt work well",
         "none of the mentioned"
      ],
      "a": [
         "works well"
      ]
   },
   {
      "q": "The direct access method is based on a --?-- model of a file, as --?-- allow random access to any file block.",
      "c": [
         "magnetic tape, magnetic tapes",
         "tape, tapes",
         "disk, disks",
         "tape, disks"
      ],
      "a": [
         "disk, disks"
      ]
   },
   {
      "q": "For a direct access file:",
      "c": [
         "there are restrictions on the order of reading and writing",
         "there are no restrictions on the order of reading and writing",
         "access is restricted permission wise",
         "access is not restricted permission wise"
      ],
      "a": [
         "there are no restrictions on the order of reading and writing"
      ]
   },
   {
      "q": "A relative block number is an index relative to:",
      "c": [
         "the beginning of the file",
         "the end of the file",
         "the last written position in file",
         "none of the mentioned"
      ],
      "a": [
         "the beginning of the file"
      ]
   },
   {
      "q": "The index contains:",
      "c": [
         "names of all contents of file",
         "pointers to each page",
         "pointers to the various blocks",
         "all of the mentioned"
      ],
      "a": [
         "pointers to the various blocks"
      ]
   },
   {
      "q": "For large files, when the index itself becomes too large to be kept in memory:",
      "c": [
         "index is called",
         "an index is created for the index file",
         "secondary index files are created",
         "all of the mentioned"
      ],
      "a": [
         "an index is created for the index file"
      ]
   },
   {
      "q": "To organise file systems on disk,:",
      "c": [
         "they are split into one or more partitions",
         "information about files is added to each partition",
         "they are made on different storage spaces",
         "all of the mentioned"
      ],
      "a": [
         "information about files is added to each partition"
      ]
   },
   {
      "q": "The directory can be viewed as a --?-- that translates file names into their directory entries.",
      "c": [
         "symbol table",
         "partition",
         "swap space",
         "cache"
      ],
      "a": [
         "symbol table"
      ]
   },
   {
      "q": "In the single level directory:",
      "c": [
         "All files are contained in different directories all at the same level",
         "All files are contained in the same directory",
         "Depends on the operating system",
         "None of the mentioned"
      ],
      "a": [
         "All files are contained in the same directory"
      ]
   },
   {
      "q": "In the single level directory:",
      "c": [
         "all directories must have unique names",
         "all files must have unique names",
         "all files must have unique owners",
         "all of the mentioned"
      ],
      "a": [
         "all files must have unique names"
      ]
   },
   {
      "q": "In the two level directory structure:",
      "c": [
         "each user has his/her own user file directory",
         "the system doesn\u2019t its own master file directory",
         "all of the mentioned",
         "none of the mentioned"
      ],
      "a": [
         "each user has his/her own user file directory"
      ]
   },
   {
      "q": "When a user job starts in a two level directory system, or a user logs in:",
      "c": [
         "the users user file directory is searched",
         "the system\u2019s master file directory is not searched",
         "the master file directory is indexed by user name or account number, and each entry points to the UFD for that user",
         "all of the mentioned"
      ],
      "a": [
         "the master file directory is indexed by user name or account number, and each entry points to the UFD for that user"
      ]
   },
   {
      "q": "The disadvantage of the two level directory structure is that:",
      "c": [
         "it does not solve the name collision problem",
         "it solves the name collision problem",
         "it does not isolate users from one another",
         "it isolates users from one another"
      ],
      "a": [
         "it isolates users from one another"
      ]
   },
   {
      "q": "In the tree structured directories:",
      "c": [
         "the tree has the stem directory",
         "the tree has the leaf directory",
         "the tree has the root directory",
         "all of the mentioned"
      ],
      "a": [
         "the tree has the root directory"
      ]
   },
   {
      "q": "The current directory contains, most of the files that are:",
      "c": [
         "of current interest to the user",
         "stored currently in the system",
         "not used in the system",
         "not of current interest to the system"
      ],
      "a": [
         "of current interest to the user"
      ]
   },
   {
      "q": "Path names can be of two types:",
      "c": [
         "absolute & relative",
         "local & global",
         "global & relative",
         "relative & local"
      ],
      "a": [
         "absolute & relative"
      ]
   },
   {
      "q": "An absolute path name begins at the:",
      "c": [
         "leaf",
         "stem",
         "current directory",
         "root"
      ],
      "a": [
         "root"
      ]
   },
   {
      "q": "A relative path name begins at the:",
      "c": [
         "leaf",
         "stem",
         "current directory",
         "root"
      ],
      "a": [
         "current directory"
      ]
   },
   {
      "q": "In tree structure, when deleting a directory that is not empty:",
      "c": [
         "The contents of the directory are safe",
         "The contents of the directory are also deleted",
         "contents of the directory are not deleted",
         "none of the mentioned"
      ],
      "a": [
         "The contents of the directory are also deleted"
      ]
   },
   {
      "q": "When two users keep a subdirectory in their own directories, the structure being referred to is:",
      "c": [
         "tree structure",
         "cyclic graph directory structure",
         "two level directory structure",
         "acyclic graph directory"
      ],
      "a": [
         "acyclic graph directory"
      ]
   },
   {
      "q": "A tree structure --?-- the sharing of files and directories.",
      "c": [
         "allows",
         "may restrict",
         "restricts",
         "none of the mentioned"
      ],
      "a": [
         "restricts"
      ]
   },
   {
      "q": "With a shared file:",
      "c": [
         "actual file exists",
         "there are two copies of the file",
         "the changes made by one person are not reflected to the other",
         "the changes made by one person are reflected to the other"
      ],
      "a": [
         "the changes made by one person are reflected to the other"
      ]
   },
   {
      "q": "In UNIX, a link is:",
      "c": [
         "a directory entry",
         "a pointer to another file or subdirectory",
         "implemented as an absolute or relative path name",
         "all of the mentioned"
      ],
      "a": [
         "all of the mentioned"
      ]
   },
   {
      "q": "The operating system --?-- the links when traversing directory trees, to preserve the acyclic structure of the system.",
      "c": [
         "considers",
         "ignores",
         "deletes",
         "none of the mentioned"
      ],
      "a": [
         "ignores"
      ]
   },
   {
      "q": "The deletion of a link, --?-- the original file.",
      "c": [
         "deletes",
         "affects",
         "does not affect",
         "none of the mentioned"
      ],
      "a": [
         "does not affect"
      ]
   },
   {
      "q": "When keeping a list of all the links/references to a file, and the list is empty, implies that:",
      "c": [
         "the file has no copies",
         "the file is deleted",
         "the file is hidden",
         "none of the mentioned"
      ],
      "a": [
         "the file is deleted"
      ]
   },
   {
      "q": "When a cycle exists, the reference count maybe non zero, even when it is no longer possible to refer to a directory or file, due to:",
      "c": [
         "the possibility of one hidden reference",
         "the possibility of two hidden references",
         "the possibility of self referencing",
         "none of the mentioned"
      ],
      "a": [
         "the possibility of self referencing"
      ]
   },
   {
      "q": "A mount point is:",
      "c": [
         "an empty directory at which the mounted file system will be attached",
         "a location where every time file systems are mounted",
         "is the time when the mounting is done",
         "none of the mentioned"
      ],
      "a": [
         "an empty directory at which the mounted file system will be attached"
      ]
   },
   {
      "q": "When a file system is mounted over a directory that is not empty:",
      "c": [
         "the system may not allow the mount",
         "the system must allow the mount",
         "the system may allow the mount and the directory\u2019s existing files will then be made obscure",
         "all of the mentioned"
      ],
      "a": [
         "the system may allow the mount and the directory\u2019s existing files will then be made obscure"
      ]
   },
   {
      "q": "In UNIX, exactly which operations can be executed by group members and other users is definable by:",
      "c": [
         "the group\u2019s head",
         "the file\u2019s owner",
         "the file\u2019s permissions",
         "all of the mentioned"
      ],
      "a": [
         "the file\u2019s owner"
      ]
   },
   {
      "q": "A process --?-- lower the priority of another process, if both are owned by the same owner.",
      "c": [
         "must",
         "can",
         "cannot",
         "none of the mentioned"
      ],
      "a": [
         "can"
      ]
   },
   {
      "q": "Anonymous access allows a user to transfer files:",
      "c": [
         "without having an account on the remote system",
         "only if he accesses the system with a guest account",
         "only if he has an account on the remote system",
         "none of the mentioned"
      ],
      "a": [
         "without having an account on the remote system"
      ]
   },
   {
      "q": "The series of accesses between the open and close operations is a:",
      "c": [
         "transaction",
         "procedure",
         "program",
         "file session"
      ],
      "a": [
         "file session"
      ]
   },
   {
      "q": "Reliability of files can be increased by:",
      "c": [
         "keeping the files safely in the memory",
         "making a different partition for the files",
         "by keeping them in external storage",
         "by keeping duplicate copies of the file"
      ],
      "a": [
         "by keeping duplicate copies of the file"
      ]
   },
   {
      "q": "Protection is only provided at the --?-- level.",
      "c": [
         "lower",
         "central",
         "higher",
         "none of the mentioned"
      ],
      "a": [
         "lower"
      ]
   },
   {
      "q": "The main problem with access control lists is:",
      "c": [
         "their maintenance",
         "their length",
         "their permissions",
         "all of the mentioned"
      ],
      "a": [
         "their length"
      ]
   },
   {
      "q": "In UNIX, groups can be created and modified by:",
      "c": [
         "superuser",
         "any user",
         "a programmer only",
         "the people in the group only"
      ],
      "a": [
         "superuser"
      ]
   },
   {
      "q": "If each access to a file is controlled by a password, then the disadvantage is that:",
      "c": [
         "user will need to remember a lot of passwords",
         "it is not reliable",
         "it is not efficient",
         "all of the mentioned"
      ],
      "a": [
         "user will need to remember a lot of passwords"
      ]
   },
   {
      "q": "In a multi level directory structure:",
      "c": [
         "the same previous techniques will be used as in the other structures",
         "a mechanism for directory protection will have to applied",
         "the subdirectories do not need protection once the directory is protected",
         "none of the mentioned"
      ],
      "a": [
         "a mechanism for directory protection will have to applied"
      ]
   },
   {
      "q": "Disks are segmented into one or more partitions, each containing a file system or:",
      "c": [
         "left \u2018raw\u2019",
         "made into swap space",
         "made into backup space",
         "left \u2018ripe\u2019"
      ],
      "a": [
         "left \u2018raw\u2019"
      ]
   },
   {
      "q": "In contiguous allocation:",
      "c": [
         "each file must occupy a set of contiguous blocks on the disk",
         "each file is a linked list of disk blocks",
         "all the pointers to scattered blocks are placed together in one location",
         "none of the mentioned"
      ],
      "a": [
         "each file must occupy a set of contiguous blocks on the disk"
      ]
   },
   {
      "q": "In linked allocation:",
      "c": [
         "each file must occupy a set of contiguous blocks on the disk",
         "each file is a linked list of disk blocks",
         "all the pointers to scattered blocks are placed together in one location",
         "none of the mentioned"
      ],
      "a": [
         "each file is a linked list of disk blocks"
      ]
   },
   {
      "q": "In indexed allocation:",
      "c": [
         "each file must occupy a set of contiguous blocks on the disk",
         "each file is a linked list of disk blocks",
         "all the pointers to scattered blocks are placed together in one location",
         "none of the mentioned"
      ],
      "a": [
         "all the pointers to scattered blocks are placed together in one location"
      ]
   },
   {
      "q": "On systems where there are multiple operating system, the decision to load a particular one is done by:",
      "c": [
         "boot loader",
         "bootstrap",
         "process control block",
         "file control block"
      ],
      "a": [
         "boot loader"
      ]
   },
   {
      "q": "The VFS (virtual file system) activates file system specific operations to handle local requests according to their:",
      "c": [
         "size",
         "commands",
         "timings",
         "file system types"
      ],
      "a": [
         "file system types"
      ]
   },
   {
      "q": "The real disadvantage of a linear list of directory entries is the:",
      "c": [
         "size of the linear list in memory",
         "linear search to find a file",
         "it is not reliable",
         "all of the mentioned"
      ],
      "a": [
         "linear search to find a file"
      ]
   },
   {
      "q": "Contiguous allocation of a file is defined by:",
      "c": [
         "disk address of the first block & length",
         "length & size of the block",
         "size of the block",
         "total size of the file"
      ],
      "a": [
         "disk address of the first block & length"
      ]
   },
   {
      "q": "One difficulty of contiguous allocation is:",
      "c": [
         "finding space for a new file",
         "inefficient",
         "costly",
         "time taking"
      ],
      "a": [
         "finding space for a new file"
      ]
   },
   {
      "q": "The first fit and best fit algorithms suffer from:",
      "c": [
         "internal fragmentation",
         "external fragmentation",
         "starvation",
         "all of the mentioned"
      ],
      "a": [
         "external fragmentation"
      ]
   },
   {
      "q": "To solve the problem of external fragmentation, --?-- needs to be done periodically.",
      "c": [
         "compaction",
         "check",
         "formatting",
         "replacing memory"
      ],
      "a": [
         "compaction"
      ]
   },
   {
      "q": "If too little space is allocated to a file:",
      "c": [
         "the file will not work",
         "there will not be any space for the data, as the FCB takes it all",
         "the file cannot be extended",
         "the file cannot be opened"
      ],
      "a": [
         "the file cannot be extended"
      ]
   },
   {
      "q": "A device driver can be thought of as a translator. Its input consists of --?-- commands and output consists of --?-- instructions.",
      "c": [
         "high level, low level",
         "low level, high level",
         "complex, simple",
         "low level, complex"
      ],
      "a": [
         "high level, low level"
      ]
   },
   {
      "q": "Metadata includes:",
      "c": [
         "all of the file system structure",
         "contents of files",
         "both file system structure and contents of files",
         "none of the mentioned"
      ],
      "a": [
         "both file system structure and contents of files"
      ]
   },
   {
      "q": "For each file there exists a --?-- that contains information about the file, including ownership, permissions and location of the file contents.",
      "c": [
         "metadata",
         "file control block",
         "process control block",
         "all of the mentioned"
      ],
      "a": [
         "file control block"
      ]
   },
   {
      "q": "For processes to request access to file contents, they need to:",
      "c": [
         "they need to run a seperate program",
         "they need special interrupts",
         "implement the open and close system calls",
         "none of the mentioned"
      ],
      "a": [
         "implement the open and close system calls"
      ]
   },
   {
      "q": "During compaction time, other normal system operations --?-- be permitted.",
      "c": [
         "can",
         "cannot",
         "is",
         "none of the mentioned"
      ],
      "a": [
         "cannot"
      ]
   },
   {
      "q": "When in contiguous allocation the space cannot be extended easily:",
      "c": [
         "the contents of the file have to be copied to a new space, a larger hole",
         "the file gets destroyed",
         "the file will get formatted and lost all its data",
         "none of the mentioned"
      ],
      "a": [
         "the contents of the file have to be copied to a new space, a larger hole"
      ]
   },
   {
      "q": "There is no --?-- with linked allocation.",
      "c": [
         "internal fragmentation",
         "external fragmentation",
         "starvation",
         "all of the mentioned"
      ],
      "a": [
         "external fragmentation"
      ]
   },
   {
      "q": "The major disadvantage with linked allocation is that:",
      "c": [
         "internal fragmentation",
         "external fragmentation",
         "there is no sequential access",
         "there is only sequential access"
      ],
      "a": [
         "there is only sequential access"
      ]
   },
   {
      "q": "If a pointer is lost or damaged in a linked allocation:",
      "c": [
         "the entire file could get damaged",
         "only a part of the file would be affected",
         "there would not be any problems",
         "none of the mentioned"
      ],
      "a": [
         "the entire file could get damaged"
      ]
   },
   {
      "q": "By using FAT, random access time is:",
      "c": [
         "the same",
         "increased",
         "decreased",
         "not affected"
      ],
      "a": [
         "decreased"
      ]
   },
   {
      "q": "A better way of contiguous allocation to extend the file size is:",
      "c": [
         "adding an extent (another chunk of contiguous space)",
         "adding an index table to the first contiguous block",
         "adding pointers into the first contiguous block",
         "none of the mentioned"
      ],
      "a": [
         "adding an extent (another chunk of contiguous space)"
      ]
   },
   {
      "q": "If the extents are too large, then the problem that comes in is:",
      "c": [
         "internal fragmentation",
         "external fragmentation",
         "starvation",
         "all of the mentioned"
      ],
      "a": [
         "internal fragmentation"
      ]
   },
   {
      "q": "The FAT is used much as a:",
      "c": [
         "stack",
         "linked list",
         "data",
         "pointer"
      ],
      "a": [
         "linked list"
      ]
   },
   {
      "q": "A section of disk at the beginning of each partition is set aside to contain the table in:",
      "c": [
         "fat",
         "linked allocation",
         "hashed allocation",
         "indexed allocation"
      ],
      "a": [
         "fat"
      ]
   },
   {
      "q": "Contiguous allocation has two problems --?-- and --?-- that linked allocation solves.",
      "c": [
         "external \u2013 fragmentation & size \u2013 declaration",
         "internal \u2013 fragmentation & external \u2013 fragmentation",
         "size \u2013 declaration & internal \u2013 fragmentation",
         "memory \u2013 allocation & size \u2013 declaration"
      ],
      "a": [
         "external \u2013 fragmentation & size \u2013 declaration"
      ]
   },
   {
      "q": "Each --?-- has its own index block.",
      "c": [
         "partition",
         "address",
         "file",
         "all of the mentioned"
      ],
      "a": [
         "file"
      ]
   },
   {
      "q": "Indexed allocation --?-- direct access.",
      "c": [
         "supports",
         "does not support",
         "is not related to",
         "none of the mentioned"
      ],
      "a": [
         "supports"
      ]
   },
   {
      "q": "The pointer overhead of indexed allocation is generally --?-- the pointer overhead of linked allocation.",
      "c": [
         "less than",
         "equal to",
         "greater than",
         "keeps varying with"
      ],
      "a": [
         "greater than"
      ]
   },
   {
      "q": "For any type of access, contiguous allocation requires --?-- access to get a disk block.",
      "c": [
         "only one",
         "at least two",
         "exactly two",
         "none of the mentioned"
      ],
      "a": [
         "only one"
      ]
   },
   {
      "q": "--?-- tend to represent a major bottleneck in system performance.",
      "c": [
         "CPUs",
         "Disks",
         "Programs",
         "I/O"
      ],
      "a": [
         "Disks"
      ]
   },
   {
      "q": "In UNIX, even an \u2019empty\u2019 disk has a percentage of its space lost to:",
      "c": [
         "programs",
         "inodes",
         "virtual memory",
         "stacks"
      ],
      "a": [
         "inodes"
      ]
   },
   {
      "q": "By preallocating the inodes and spreading them across the volume, we --?-- the system performance.",
      "c": [
         "improve",
         "decrease",
         "maintain",
         "do not affect"
      ],
      "a": [
         "improve"
      ]
   },
   {
      "q": "--?-- writes occur in the order in which the disk subsystem receives them, and the writes are not buffered.",
      "c": [
         "Asynchronous",
         "Regular",
         "Synchronous",
         "Irregular"
      ],
      "a": [
         "Synchronous"
      ]
   },
   {
      "q": "In --?-- writes, the data is stored in the cache.",
      "c": [
         "Asynchronous",
         "Regular",
         "Synchronous",
         "Irregular"
      ],
      "a": [
         "Asynchronous"
      ]
   },
   {
      "q": "A file being read or written sequentially should not have its pages replaced in LRU order, because:",
      "c": [
         "it is very costly",
         "the most recently used page will be used last",
         "it is not efficient",
         "all of the mentioned"
      ],
      "a": [
         "the most recently used page will be used last"
      ]
   },
   {
      "q": "In the optimized technique for sequential access --?-- removes a page from the buffer as soon as the next page is requested.",
      "c": [
         "write ahead",
         "read ahead",
         "free-behind",
         "add-front"
      ],
      "a": [
         "free-behind"
      ]
   },
   {
      "q": "With --?-- a requested page and several subsequent pages are read and cached.",
      "c": [
         "write ahead",
         "read ahead",
         "free-behind",
         "add-front"
      ],
      "a": [
         "read ahead"
      ]
   },
   {
      "q": "Some directory information is kept in main memory or cache to:",
      "c": [
         "fill up the cache",
         "increase free space in secondary storage",
         "speed up access"
      ],
      "a": [
         "speed up access"
      ]
   },
   {
      "q": "A consistency checker --?-- and tries to fix any inconsistencies it finds.",
      "c": [
         "compares the data in the secondary storage with the data in the cache",
         "compares the data in the directory structure with the data blocks on disk",
         "compares the system generated output and user required output",
         "all of the mentioned"
      ],
      "a": [
         "compares the data in the directory structure with the data blocks on disk"
      ]
   },
   {
      "q": "Each set of operations for performing a specific task is a:",
      "c": [
         "program",
         "code",
         "transaction",
         "all of the mentioned"
      ],
      "a": [
         "transaction"
      ]
   },
   {
      "q": "Once the changes are written to the log, they are considered to be:",
      "c": [
         "committed",
         "aborted",
         "completed",
         "none of the mentioned"
      ],
      "a": [
         "committed"
      ]
   },
   {
      "q": "When an entire committed transaction is completed:",
      "c": [
         "it is stored in the memory",
         "it is removed from the log file",
         "it is redone",
         "none of the mentioned"
      ],
      "a": [
         "it is removed from the log file"
      ]
   },
   {
      "q": "A circular buffer:",
      "c": [
         "writes to the end of its space and then continues at the beginning",
         "overwrites older values as it goes",
         "all of the mentioned",
         "none of the mentioned"
      ],
      "a": [
         "writes to the end of its space and then continues at the beginning"
      ]
   },
   {
      "q": "All the changes that were done from a transaction that did not commit before the system crashed, have to be:",
      "c": [
         "saved",
         "saved and the transaction redone",
         "undone",
         "none of the mentioned"
      ],
      "a": [
         "undone"
      ]
   },
   {
      "q": "A machine in Network file system (NFS) can be:",
      "c": [
         "client",
         "server",
         "both client and server",
         "neither client nor server"
      ],
      "a": [
         "both client and server"
      ]
   },
   {
      "q": "The --?-- becomes the name of the root of the newly mounted directory.",
      "c": [
         "root of the previous directory",
         "local directory",
         "remote directory itself",
         "none of the mentioned"
      ],
      "a": [
         "local directory"
      ]
   },
   {
      "q": "--?-- mounts, is when a file system can be mounted over another file system, that is remotely mounted, not local.",
      "c": [
         "recursive",
         "cascading",
         "trivial",
         "none of the mentioned"
      ],
      "a": [
         "cascading"
      ]
   },
   {
      "q": "The mount request is mapped to the corresponding --?-- and is forwarded to the mount server running on the specific server machine.",
      "c": [
         "IPC",
         "System",
         "CPU",
         "RPC"
      ],
      "a": [
         "System"
      ]
   },
   {
      "q": "The server maintains a/an --?-- that specifies local file systems that it exports for mounting, along with names of machines that are permitted to mount them.",
      "c": [
         "export list",
         "import list",
         "sending list",
         "receiving list"
      ],
      "a": [
         "export list"
      ]
   },
   {
      "q": "When a client has a cascading mount, --?-- server(s) is/are involved in a path name traversal.",
      "c": [
         "at least one",
         "more than one",
         "more than two",
         "more than three"
      ],
      "a": [
         "more than one"
      ]
   },
   {
      "q": "I/O hardware contains:",
      "c": [
         "Bus",
         "Controller",
         "I/O port and its registers",
         "All of the mentioned"
      ],
      "a": [
         "All of the mentioned"
      ]
   },
   {
      "q": "The data-in register of I/O port is:",
      "c": [
         "Read by host to get input",
         "Read by controller to get input",
         "Written by host to send output",
         "Written by host to start a command"
      ],
      "a": [
         "Read by host to get input"
      ]
   },
   {
      "q": "The host sets --?-- bit when a command is available for the controller to execute.",
      "c": [
         "write",
         "status",
         "command-ready",
         "control"
      ],
      "a": [
         "command-ready"
      ]
   },
   {
      "q": "When hardware is accessed by reading and writing to the specific memory locations, then it is called:",
      "c": [
         "port-mapped I/O",
         "controller-mapped I/O",
         "bus-mapped I/O",
         "none of the mentioned"
      ],
      "a": [
         "none of the mentioned"
      ]
   },
   {
      "q": "Which hardware triggers some operation after certain programmed count?",
      "c": [
         "programmable interval timer",
         "interrupt timer",
         "programmable timer",
         "none of the mentioned"
      ],
      "a": [
         "programmable interval timer"
      ]
   },
   {
      "q": "The device-status table contains:",
      "c": [
         "each I/O device type",
         "each I/O device address",
         "each I/O device state",
         "all of the mentioned"
      ],
      "a": [
         "all of the mentioned"
      ]
   },
   {
      "q": "Which buffer holds the output for a device?",
      "c": [
         "spool",
         "output",
         "status",
         "magic"
      ],
      "a": [
         "spool"
      ]
   },
   {
      "q": "Which one of the following connects high-speed high-bandwidth device to memory subsystem and CPU.",
      "c": [
         "Expansion bus",
         "PCI bus",
         "SCSI bus",
         "None of the mentioned"
      ],
      "a": [
         "Expansion bus"
      ]
   },
   {
      "q": "A process is moved to wait queue when I/O request is made with:",
      "c": [
         "non-blocking I/O",
         "blocking I/O",
         "asynchronous I/O",
         "synchronous I/O"
      ],
      "a": [
         "blocking I/O"
      ]
   },
   {
      "q": "In --?-- information is recorded magnetically on platters.",
      "c": [
         "magnetic disks",
         "electrical disks",
         "assemblies",
         "cylinders"
      ],
      "a": [
         "magnetic disks"
      ]
   },
   {
      "q": "The heads of the magnetic disk are attached to a --?-- that moves all the heads as a unit.",
      "c": [
         "spindle",
         "disk arm",
         "track",
         "none of the mentioned"
      ],
      "a": [
         "disk arm"
      ]
   },
   {
      "q": "The set of tracks that are at one arm position make up a:",
      "c": [
         "magnetic disks",
         "electrical disks",
         "assemblies",
         "cylinders"
      ],
      "a": [
         "cylinders"
      ]
   },
   {
      "q": "The time taken to move the disk arm to the desired cylinder is called the:",
      "c": [
         "positioning time",
         "random access time",
         "seek time",
         "rotational latency"
      ],
      "a": [
         "seek time"
      ]
   },
   {
      "q": "The time taken for the desired sector to rotate to the disk head is called:",
      "c": [
         "positioning time",
         "random access time",
         "seek time",
         "rotational latency"
      ],
      "a": [
         "rotational latency"
      ]
   },
   {
      "q": "When the head damages the magnetic surface, it is known as:",
      "c": [
         "disk crash",
         "head crash",
         "magnetic damage",
         "all of the mentioned"
      ],
      "a": [
         "head crash"
      ]
   },
   {
      "q": "A floppy disk is designed to rotate --?-- as compared to a hard disk drive.",
      "c": [
         "faster",
         "slower",
         "at the same speed",
         "none of the mentioned"
      ],
      "a": [
         "slower"
      ]
   },
   {
      "q": "The host controller is:",
      "c": [
         "controller built at the end of each disk",
         "controller at the computer end of the bus",
         "all of the mentioned",
         "none of the mentioned"
      ],
      "a": [
         "controller at the computer end of the bus"
      ]
   },
   {
      "q": "--?-- controller sends the command placed into it, via messages to the --?-- controller.",
      "c": [
         "host, host",
         "disk, disk",
         "host, disk",
         "disk, host"
      ],
      "a": [
         "host, disk"
      ]
   },
   {
      "q": "The disk bandwidth is:",
      "c": [
         "the total number of bytes transferred",
         "total time between the first request for service and the completion on the last transfer",
         "the total number of bytes transferred divided by the total time between the first request for service and the completion on the last transfer",
         "none of the mentioned"
      ],
      "a": [
         "the total number of bytes transferred divided by the total time between the first request for service and the completion on the last transfer"
      ]
   },
   {
      "q": "Whenever a process needs I/O to or from a disk it issues a:",
      "c": [
         "system call to the CPU",
         "system call to the operating system",
         "a special procedure",
         "all of the mentioned"
      ],
      "a": [
         "system call to the operating system"
      ]
   },
   {
      "q": "If a process needs I/O to or from a disk, and if the drive or controller is busy then:",
      "c": [
         "the request will be placed in the queue of pending requests for that drive",
         "the request will not be processed and will be ignored completely",
         "the request will be not be placed",
         "none of the mentioned"
      ],
      "a": [
         "the request will be placed in the queue of pending requests for that drive"
      ]
   },
   {
      "q": "Random access in magnetic tapes is --?-- compared to magnetic disks.",
      "c": [
         "fast",
         "very fast",
         "slow",
         "very slow"
      ],
      "a": [
         "very slow"
      ]
   },
   {
      "q": "Magnetic tape drives can write data at a speed --?-- disk drives.",
      "c": [
         "much lesser than",
         "comparable to",
         "much faster than",
         "none of the mentioned"
      ],
      "a": [
         "comparable to"
      ]
   },
   {
      "q": "On media that use constant linear velocity (CLV), the --?-- is uniform.",
      "c": [
         "density of bits on the disk",
         "density of bits per sector",
         "the density of bits per track",
         "none of the mentioned"
      ],
      "a": [
         "the density of bits per track"
      ]
   },
   {
      "q": "In the --?-- algorithm, the disk arm starts at one end of the disk and moves toward the other end, servicing requests till the other end of the disk. At the other end, the direction is reversed and servicing continues.",
      "c": [
         "LOOK",
         "SCAN",
         "C-SCAN",
         "C-LOOK"
      ],
      "a": [
         "SCAN"
      ]
   },
   {
      "q": "In the --?-- algorithm, the disk head moves from one end to the other , servicing requests along the way. When the head reaches the other end, it immediately returns to the beginning of the disk without servicing any requests on the return trip.",
      "c": [
         "LOOK",
         "SCAN",
         "C-SCAN",
         "C-LOOK"
      ],
      "a": [
         "C-SCAN"
      ]
   },
   {
      "q": "In the --?-- algorithm, the disk arm goes as far as the final request in each direction, then reverses direction immediately without going to the end of the disk.",
      "c": [
         "LOOK",
         "SCAN",
         "C-SCAN",
         "C-LOOK"
      ],
      "a": [
         "LOOK"
      ]
   },
   {
      "q": "The process of dividing a disk into sectors that the disk controller can read and write, before a disk can store data is known as:",
      "c": [
         "partitioning",
         "swap space creation",
         "low-level formatting",
         "none of the mentioned"
      ],
      "a": [
         "low-level formatting"
      ]
   },
   {
      "q": "The data structure for a sector typically contains:",
      "c": [
         "header",
         "data area",
         "trailer",
         "all of the mentioned"
      ],
      "a": [
         "all of the mentioned"
      ]
   },
   {
      "q": "The header and trailer of a sector contain information used by the disk controller such as --?-- and --?--",
      "c": [
         "main section & disk identifier",
         "error correcting codes (ECC) & sector number",
         "sector number & main section",
         "disk identifier & sector number"
      ],
      "a": [
         "error correcting codes (ECC) & sector number"
      ]
   },
   {
      "q": "The two steps the operating system takes to use a disk to hold its files are --?-- and --?-- .",
      "c": [
         "partitioning & logical formatting",
         "swap space creation & caching",
         "caching & logical formatting",
         "logical formatting & swap space creation"
      ],
      "a": [
         "partitioning & logical formatting"
      ]
   },
   {
      "q": "The --?-- program initializes all aspects of the system, from CPU registers to device controllers and the contents of main memory, and then starts the operating system.",
      "c": [
         "main",
         "bootloader",
         "bootstrap",
         "rom"
      ],
      "a": [
         "bootstrap"
      ]
   },
   {
      "q": "For most computers, the bootstrap is stored in:",
      "c": [
         "RAM",
         "ROM",
         "Cache",
         "Tertiary storage"
      ],
      "a": [
         "ROM"
      ]
   },
   {
      "q": "A disk that has a boot partition is called a:",
      "c": [
         "start disk",
         "end disk",
         "boot disk",
         "all of the mentioned"
      ],
      "a": [
         "boot disk"
      ]
   },
   {
      "q": "Defective sectors on disks are often known as:",
      "c": [
         "good blocks",
         "destroyed blocks",
         "bad blocks",
         "none of the mentioned"
      ],
      "a": [
         "bad blocks"
      ]
   },
   {
      "q": "In SCSI disks used in high end PCs, the controller maintains a list of --?-- on the disk. The disk is initialized during --?-- formatting which sets aside spare sectors not visible to the operating system.",
      "c": [
         "destroyed blocks, high level formatting",
         "bad blocks, partitioning",
         "bad blocks, low level formatting",
         "destroyed blocks, partitioning"
      ],
      "a": [
         "bad blocks, low level formatting"
      ]
   },
   {
      "q": "An unrecoverable error is known as:",
      "c": [
         "hard error",
         "tough error",
         "soft error",
         "none of the mentioned"
      ],
      "a": [
         "hard error"
      ]
   },
   {
      "q": "Virtual memory uses disk space as an extension of:",
      "c": [
         "secondary storage",
         "main memory",
         "tertiary storage",
         "none of the mentioned"
      ],
      "a": [
         "main memory"
      ]
   },
   {
      "q": "Using swap space significantly --?-- system performance.",
      "c": [
         "increases",
         "decreases",
         "maintains",
         "does not affect"
      ],
      "a": [
         "decreases"
      ]
   },
   {
      "q": "A single swap space --?-- reside in two places.",
      "c": [
         "can",
         "cannot",
         "must not",
         "none of the mentioned"
      ],
      "a": [
         "can"
      ]
   },
   {
      "q": "If the swap space is simply a large file, within the file system, --?-- used to create it, name it and allocate its space.",
      "c": [
         "special routines must be",
         "normal file system routines can be",
         "normal file system routines cannot be",
         "swap space storage manager is"
      ],
      "a": [
         "normal file system routines can be"
      ]
   },
   {
      "q": "For swap space created in a separate disk partition where no file system or directory structure is placed, --?-- used to allocate and deallocate the blocks.",
      "c": [
         "special routines must be",
         "normal file system routines can be",
         "normal file system routines cannot be",
         "swap space storage manager is"
      ],
      "a": [
         "swap space storage manager is"
      ]
   },
   {
      "q": "It is __________ to reread a page from the file system than to write it to swap space and then to reread it from there.",
      "c": [
         "useless",
         "less efficient",
         "more efficient",
         "none of the mentioned"
      ],
      "a": [
         "more efficient"
      ]
   },
   {
      "q": "A write of a block has to access:",
      "c": [
         "the disk on which the block is stored",
         "parity disk",
         "a parity block",
         "all of the mentioned"
      ],
      "a": [
         "all of the mentioned"
      ]
   },
   {
      "q": "A large number of disks in a system improves the rate at which data can be read or written:",
      "c": [
         "if the disks are operated on sequentially",
         "if the disks are operated on selectively",
         "if the disks are operated in parallel",
         "all of the mentioned"
      ],
      "a": [
         "if the disks are operated in parallel"
      ]
   },
   {
      "q": "The solution to the problem of reliability is the introduction of:",
      "c": [
         "aging",
         "scheduling",
         "redundancy",
         "disks"
      ],
      "a": [
         "redundancy"
      ]
   },
   {
      "q": "The technique of duplicating every disk is known as:",
      "c": [
         "mirroring",
         "shadowing",
         "redundancy",
         "all of the mentioned"
      ],
      "a": [
         "mirroring"
      ]
   },
   {
      "q": "A single parity bit can be used for:",
      "c": [
         "detection",
         "multiple error corrections",
         "few error corrections",
         "all of the mentioned"
      ],
      "a": [
         "detection"
      ]
   },
   {
      "q": "In domain structure what is Access-right equal to?",
      "c": [
         "Access-right = object-name, rights-set",
         "Access-right = read-name, write-set",
         "Access-right = read-name, execute-set",
         "Access-right = object-name, execute-set"
      ],
      "a": [
         "Access-right = object-name, rights-set"
      ]
   },
   {
      "q": "What is meaning of right-set?",
      "c": [
         "It is a subset consist of read and write",
         "It is a subset of all valid operations that can be performed on the object",
         "It is a subset consist of read,write and execute",
         "None of the mentioned"
      ],
      "a": [
         "It is a subset of all valid operations that can be performed on the object"
      ]
   },
   {
      "q": "What is Domain?",
      "c": [
         "Set of all objects",
         "Collection of protection policies",
         "Set of access-rights",
         "None of the mentioned"
      ],
      "a": [
         "Set of access-rights"
      ]
   },
   {
      "q": "What does access matrix represent?",
      "c": [
         "Rows-Domains, Columns-Objects",
         "Rows-Objects, Columns-Domains",
         "Rows-Access List, Columns-Domains",
         "Rows-Domains, Columns-Access list"
      ],
      "a": [
         "Rows-Domains, Columns-Objects"
      ]
   },
   {
      "q": "Who can add new rights and remove some rights?",
      "c": [
         "copy",
         "transfer",
         "limited copy",
         "owner"
      ],
      "a": [
         "owner"
      ]
   },
   {
      "q": "Which two rights allow a process to change the entries in a column?",
      "c": [
         "copy and transfer",
         "copy and owner",
         "owner and transfer",
         "deny and copy"
      ],
      "a": [
         "copy and transfer"
      ]
   },
   {
      "q": "Which is an unsolvable problem in access-matrix?",
      "c": [
         "Owner override",
         "Brute force",
         "Access denied",
         "Confinement"
      ],
      "a": [
         "Confinement"
      ]
   },
   {
      "q": "Which of the following objects require protection?",
      "c": [
         "CPU",
         "Printers",
         "Motherboard",
         "All of the mentioned"
      ],
      "a": [
         "Printers"
      ]
   },
   {
      "q": "What is \u2018separation\u2019 in security of Operating systems?",
      "c": [
         "To have separate login for different users",
         "To have separate Hard disk drive/partition for different users",
         "It means keeping one user\u2019s objects separate from other users",
         "None of the mentioned"
      ],
      "a": [
         "It means keeping one user\u2019s objects separate from other users"
      ]
   },
   {
      "q": "What are various roles of protection?",
      "c": [
         "It is used to detect errors which can prevent contamination of system",
         "It is used used to accelerate a process",
         "It is used to optimize system downtime",
         "None of the mentioned"
      ],
      "a": [
         "It is used to detect errors which can prevent contamination of system"
      ]
   },
   {
      "q": "Which of the following objects require protection?",
      "c": [
         "Memory",
         "Monitor",
         "Power supply unit",
         "All of the mentioned"
      ],
      "a": [
         "Memory"
      ]
   },
   {
      "q": "Which principle states that programs, users and even the systems be given just enough privileges to perform their task?",
      "c": [
         "principle of operating system",
         "principle of least privilege",
         "principle of process scheduling",
         "none of the mentioned"
      ],
      "a": [
         "principle of least privilege"
      ]
   },
   {
      "q": "______ is an approach to restricting system access to authorized users.",
      "c": [
         "Role-based access control",
         "Process-based access control",
         "Job-based access control",
         "None of the mentioned"
      ],
      "a": [
         "Role-based access control"
      ]
   },
   {
      "q": "For system protection, a process should access:",
      "c": [
         "all the resources",
         "only those resources for which it has authorization",
         "few resources but authorization is not required",
         "all of the mentioned"
      ],
      "a": [
         "only those resources for which it has authorization"
      ]
   },
   {
      "q": "The protection domain of a process contains:",
      "c": [
         "object name",
         "rights-set",
         "both object name and rights-set",
         "none of the mentioned"
      ],
      "a": [
         "both object name and rights-set"
      ]
   },
   {
      "q": "If the set of resources available to the process is fixed throughout the process\u2019s lifetime then its domain is:",
      "c": [
         "static",
         "dynamic",
         "neither static nor dynamic",
         "none of the mentioned"
      ],
      "a": [
         "static"
      ]
   },
   {
      "q": "Access matrix model for user authentication contains:",
      "c": [
         "a list of objects",
         "a list of domains",
         "a function which returns an object\u2019s type",
         "all of the mentioned"
      ],
      "a": [
         "all of the mentioned"
      ]
   },
   {
      "q": "Global table implementation of matrix table contains:",
      "c": [
         "domain",
         "object",
         "right-set",
         "all of the mentioned"
      ],
      "a": [
         "all of the mentioned"
      ]
   },
   {
      "q": "For a domain _______ is a list of objects together with the operation allowed on these objects.",
      "c": [
         "capability list",
         "access list",
         "both capability and access list",
         "none of the mentioned"
      ],
      "a": [
         "capability list"
      ]
   },
   {
      "q": "In UNIX, domain switch is accomplished via:",
      "c": [
         "file system",
         "user",
         "superuser",
         "none of the mentioned"
      ],
      "a": [
         "file system"
      ]
   },
   {
      "q": "When an attempt is to make a machine or network resource unavailable to its intended users, the attack is called:",
      "c": [
         "denial-of-service attack",
         "slow read attack",
         "spoofed attack",
         "tarvation attack"
      ],
      "a": [
         "denial-of-service attack"
      ]
   },
   {
      "q": "The code segment that misuses its environment is called a:",
      "c": [
         "internal thief",
         "trojan horse",
         "code stacker",
         "none of the mentioned"
      ],
      "a": [
         "trojan horse"
      ]
   },
   {
      "q": "The internal code of any software that will set of a malicious function when specified conditions are met, is called:",
      "c": [
         "logic bomb",
         "trap door",
         "code stacker",
         "none of the mentioned"
      ],
      "a": [
         "logic bomb"
      ]
   },
   {
      "q": "The pattern that can be used to identify a virus is known as:",
      "c": [
         "stealth",
         "virus signature",
         "armoured",
         "multipartite"
      ],
      "a": [
         "virus signature"
      ]
   },
   {
      "q": "Which one of the following is a process that uses the spawn mechanism to revage the system performance?",
      "c": [
         "worm",
         "trojan",
         "threat",
         "virus"
      ],
      "a": [
         "worm"
      ]
   },
   {
      "q": "Which one of the following is not an attack, but a search for vulnerabilities to attack?",
      "c": [
         "denial of service",
         "port scanning",
         "memory access violation",
         "dumpster diving"
      ],
      "a": [
         "port scanning"
      ]
   },
   {
      "q": "File virus attaches itself to the",
      "c": [
         "source file",
         "object file",
         "executable file",
         "all of the mentioned"
      ],
      "a": [
         "executable file"
      ]
   },
   {
      "q": "Multipartite viruses attack on:",
      "c": [
         "files",
         "boot sector",
         "memory",
         "all of the mentioned"
      ],
      "a": [
         "all of the mentioned"
      ]
   },
   {
      "q": "What is correct regarding \u2018relocation\u2019 w.r.t protecting memory?",
      "c": [
         "It is a process of taking a program as if it began at address 0",
         "It is a process of taking a program as if it began at address 0A",
         "Fence cannot be used within relocation process",
         "All of the mentioned"
      ],
      "a": [
         "It is a process of taking a program as if it began at address 0"
      ]
   },
   {
      "q": "What is basic need in protecting memory in multi-user environment?",
      "c": [
         "We need two registers one \u2018start\u2019 and other \u2018end\u2019",
         "We need a variable register",
         "A fence register has to be used known as base register.",
         "None of the mentioned"
      ],
      "a": [
         "A fence register has to be used known as base register."
      ]
   },
   {
      "q": "What is role of base/bound registers?",
      "c": [
         "They give starting address to a program",
         "Program\u2019s addresses are neatly confined to space between the base and the bound registers",
         "They provide encrypted environment",
         "This technique doesn\u2019t protects a program\u2019s address from modification by another user"
      ],
      "a": [
         "Program\u2019s addresses are neatly confined to space between the base and the bound registers"
      ]
   },
   {
      "q": "What is all-or-nothing situation for sharing in memory?",
      "c": [
         "Program makes all its data available to be accessed",
         "It prohibits access to some",
         "It creates rules who can access program memory",
         "It separates program memory and data memory"
      ],
      "a": [
         "Program makes all its data available to be accessed"
      ]
   },
   {
      "q": "How is disadvantage of all-or-nothing approach overcome?",
      "c": [
         "Base/Bound",
         "Relocation technique",
         "Fence method",
         "Tagged architecture"
      ],
      "a": [
         "Tagged architecture"
      ]
   },
   {
      "q": "What is true regarding tagged architecture?",
      "c": [
         "Every word of machine memory has one or more extra bits",
         "Extra bits are used to do padding",
         "Extra bits are not used to identify rights to that word",
         "It is very compatible to code upgrades"
      ],
      "a": [
         "Every word of machine memory has one or more extra bits"
      ]
   },
   {
      "q": "What is best solution to have effect of unbounded number if base/bound registers?",
      "c": [
         "Tagged architecture",
         "Segmentation",
         "Fence method",
         "None of the mentioned"
      ],
      "a": [
         "Segmentation"
      ]
   },
   {
      "q": "What is major feature of segmentation?",
      "c": [
         "Program is divided in data memory and program memory",
         "Program is executed in segments",
         "Program is divided into pieces having different access rights",
         "It has effect of an unbounded architecture"
      ],
      "a": [
         "Program is divided into pieces having different access rights"
      ]
   },
   {
      "q": "What is correct way the segmentation program address is stored?",
      "c": [
         "name, offset",
         "start, stop",
         "access, rights",
         "offset, rights"
      ],
      "a": [
         "name, offset"
      ]
   },
   {
      "q": "What is main objective of protection?",
      "c": [
         "Ensure all objects are protected individually",
         "Objects have different priority and thus different levels of protection",
         "Ensure that each object is accessed correctly and only by allowed processes",
         "None of the mentioned"
      ],
      "a": [
         "Ensure that each object is accessed correctly and only by allowed processes"
      ]
   },
   {
      "q": "What is principle of least privilege?",
      "c": [
         "Less privileges provide difficulty in executing admin tasks",
         "Users can get temporary high privilege access",
         "Users should be given just enough privileges to perform their tasks",
         "None of the mentioned"
      ],
      "a": [
         "Users should be given just enough privileges to perform their tasks"
      ]
   },
   {
      "q": "What is incorrect methods of revocation of access rights?",
      "c": [
         "Immediate/Delayed",
         "Selective/General",
         "Partial/total",
         "Crucial"
      ],
      "a": [
         "Crucial"
      ]
   },
   {
      "q": "Why is it difficult to revoke capabilities?",
      "c": [
         "They are too many",
         "They are not defined precicely",
         "They are distributed throughout the system",
         "None of the mentioned"
      ],
      "a": [
         "They are distributed throughout the system"
      ]
   },
   {
      "q": "What is the reacquisition scheme to revoke capability?",
      "c": [
         "When a process capability is revoked then it won\u2019t be able to reacquire it",
         "Pointers are maintained for each object which can be used to revoke",
         "Indirect pointing is done to revoke object\u2019s capabilities",
         "Master key can be used compare and revoke."
      ],
      "a": [
         "When a process capability is revoked then it won\u2019t be able to reacquire it"
      ]
   },
   {
      "q": "What is true about Indirection to revoke capability?",
      "c": [
         "Capabilities point indirectly to the objects",
         "Each capability will not have a unique entry in global",
         "Table entries cannot be reused for other capabilities",
         "This system was adopted in MULTICS system"
      ],
      "a": [
         "Capabilities point indirectly to the objects"
      ]
   },
   {
      "q": "What is the problem of mutually suspicious subsystem?",
      "c": [
         "Service program can steal users data",
         "Service program can malfunction and retain some rights of data provided by user",
         "Calling program can get access to restricted portion from service program",
         "Calling program gets unrestricted access"
      ],
      "a": [
         "Service program can malfunction and retain some rights of data provided by user"
      ]
   },
   {
      "q": "Users and application programmers communicate with hardware through:",
      "c": [
         "program instructions",
         "a channel",
         "the operating system",
         "all of the mentioned"
      ],
      "a": [
         "the operating system"
      ]
   },
   {
      "q": "Most modern operating systems include:",
      "c": [
         "processor management",
         "file management",
         "memory management",
         "all of the mentioned"
      ],
      "a": [
         "all of the mentioned"
      ]
   },
   {
      "q": "In addition to providing a user interface, the operating system:",
      "c": [
         "manages system resources",
         "complicates programming"
      ],
      "a": [
         "manages system resources"
      ]
   },
   {
      "q": "The operating system's routines perform key support functions such as:",
      "c": [
         "communicating with peripheral devices",
         "accepting and carrying out user commands",
         "both"
      ],
      "a": [
         "both"
      ]
   },
   {
      "q": "The file management function incorporates routines that allow the user or programmer to:",
      "c": [
         "create files by name",
         "delete files by name",
         "modify files by name",
         "all of the mentioned"
      ],
      "a": [
         "all of the mentioned"
      ]
   },
   {
      "q": "The processor fetches and executes one instruction during each:",
      "c": [
         "clock pulse",
         "execution cycle",
         "instruction cycle",
         "machine cycle"
      ],
      "a": [
         "machine cycle"
      ]
   },
   {
      "q": "The time that is required to bring a disk drive up to speed and position the access mechanism is called:",
      "c": [
         "access time",
         "rotational delay",
         "seek time",
         "execution time"
      ],
      "a": [
         "seek time"
      ]
   },
   {
      "q": "To find a particular file on a disk, refer to the disk's:",
      "c": [
         "table of contents",
         "directory",
         "buffer",
         "control unit"
      ],
      "a": [
         "directory"
      ]
   },
   {
      "q": "Temporary storage called --?-- can be used to adjust for the speed disparity between devices.",
      "c": [
         "a buffer",
         "an interface",
         "a control unit",
         "a channel"
      ],
      "a": [
         "a buffer"
      ]
   },
   {
      "q": "On a mainframe, device-dependent I/O functions are assigned to:",
      "c": [
         "a channel",
         "a control unit",
         "an interface",
         "a buffer"
      ],
      "a": [
         "a channel"
      ]
   },
   {
      "q": "Programmers code at the --?-- level.",
      "c": [
         "object",
         "load",
         "machine",
         "source"
      ],
      "a": [
         "source"
      ]
   },
   {
      "q": "If key routines are stored --?--, a programmer can incorporate them in his or her program and thus avoid rewriting them.",
      "c": [
         "in memory",
         "on disk",
         "in a library",
         "in an object"
      ],
      "a": [
         "in a library"
      ]
   },
   {
      "q": "Given a start of file address, the location of any given record can be computed from its:",
      "c": [
         "key",
         "relative record number",
         "data object",
         "source structure"
      ],
      "a": [
         "relative record number"
      ]
   },
   {
      "q": "On most computer systems, the internal components are designed around a common:",
      "c": [
         "interface",
         "byte size",
         "word size",
         "protocol"
      ],
      "a": [
         "word size"
      ]
   },
   {
      "q": "The access method is added to the program load module by the:",
      "c": [
         "compiler",
         "programmer",
         "linkage editor",
         "internal component"
      ],
      "a": [
         "linkage editor"
      ]
   },
   {
      "q": "Interfaces and control units execute:",
      "c": [
         "machine-level commands",
         "object-level commands",
         "primitive commands",
         "none of the mentioned"
      ],
      "a": [
         "primitive commands"
      ]
   },
   {
      "q": "By --?-- data (storing several logical records in a single block sector), disk space can be better utilized.",
      "c": [
         "blocking",
         "encoding",
         "encrypting",
         "compressing"
      ],
      "a": [
         "blocking"
      ]
   },
   {
      "q": "Managing a disk directory is a key function of the:",
      "c": [
         "IOCS",
         "command processor",
         "boot routine",
         "file system"
      ],
      "a": [
         "file system"
      ]
   },
   {
      "q": "To create a new file or find an existing file, a program executes:",
      "c": [
         "a read instruction",
         "a save command",
         "a load command",
         "an open command"
      ],
      "a": [
         "an open command"
      ]
   },
   {
      "q": "On most computers, a peripheral establishes communication with the opening system by sending:",
      "c": [
         "a protocol signal",
         "an interrupt",
         "a command",
         "a request"
      ],
      "a": [
         "an interrupt"
      ]
   },
   {
      "q": "Under --?-- memory management, only active portions of a program are actually stored in main memory.",
      "c": [
         "fixed-partition",
         "dynamic",
         "virtual",
         "fragmented"
      ],
      "a": [
         "virtual"
      ]
   },
   {
      "q": "Pages are swapped into and out from the real memory:",
      "c": [
         "page pool",
         "V-R area",
         "paging device",
         "partitions"
      ],
      "a": [
         "page pool"
      ]
   },
   {
      "q": "If two routines each control a resource needed by the other and neither is willing to give in, --?-- can occur.",
      "c": [
         "an interrupt",
         "deadlock",
         "a time-slice",
         "a race condition"
      ],
      "a": [
         "deadlock"
      ]
   },
   {
      "q": "Copying data to disk for eventual input to an application routine is called:",
      "c": [
         "queuing",
         "spooling",
         "dispatching",
         "multiprogramming"
      ],
      "a": [
         "spooling"
      ]
   },
   {
      "q": "Virtual memory is a --?-- of memory contents.",
      "c": [
         "physical model",
         "duplicate",
         "mirror image",
         "logical model"
      ],
      "a": [
         "logical model"
      ]
   },
   {
      "q": "Most time-sharing systems rely on --?-- to manage memory space.",
      "c": [
         "time-slicing",
         "interrupts",
         "polling",
         "roll-in/roll-out"
      ],
      "a": [
         "time-slicing"
      ]
   },
   {
      "q": "Under --?--, programs are divided into variable length pieces.",
      "c": [
         "segmentation",
         "paging",
         "dynamic memory management",
         "fixed partitions"
      ],
      "a": [
         "segmentation"
      ]
   },
   {
      "q": "Under --?--, programs are divided into fixed length pieces.",
      "c": [
         "segmenting",
         "paging",
         "dynamic memory management",
         "fixed partitions"
      ],
      "a": [
         "paging"
      ]
   },
   {
      "q": "A synchronious event that is generated when the processor detects a predefined condition is called a(n):",
      "c": [
         "interrupt",
         "exception",
         "page fault",
         "the IDT"
      ],
      "a": [
         "exception"
      ]
   },
   {
      "q": "Associated with every interrupt is an identification number called a(n):",
      "c": [
         "interrupt ID",
         "IDT",
         "vector",
         "interrupt description number"
      ],
      "a": [
         "vector"
      ]
   }
]
